/// <reference types="mocha" />
/// <reference types="sinon-as-promised" />

import { expect, assert, use } from 'chai'
import { QueueConsumer, handleAsyncError } from '../../src/queues/queueConsumer'
import { QueueService } from '../../src/queues/queueService'
import { IConsumeQueueOptions, IQueueMessage, IQueueConsumerEvent, IDeleteMessagesResult } from '../../src/queues'
import * as sinon from 'sinon'
import * as sinonChai from 'sinon-chai'
use(sinonChai)
import 'sinon-as-promised'
import * as Faker from 'faker'
import * as _ from 'lodash'
import * as Promise from 'bluebird'

const genMsg = () => { return { Id: Faker.random.uuid() } }

describe('QueueConsumer', function () {
  let subject: QueueConsumer<any, any> = null
  let queueService: any = null
  beforeEach(function () {
    queueService = sinon.createStubInstance(QueueService)
    subject = new QueueConsumer(queueService)
  })
  describe('constructor', function () {
    it('should error without QueueService', function () {
      assert.throws(() => {
        return new QueueConsumer(null)
      })
    })
  })
  describe('handleAsyncError', function () {
    it('should rethrown either the OperationalError.cause or Error ', function () {
      expect(() => handleAsyncError(new Error('abc')))
        .to.throw(Error)
      let oe = new Promise.OperationalError('msg')
      oe.cause = new TypeError('abc')
      expect(() => handleAsyncError(oe)).to.throw(TypeError)
      oe = new Promise.OperationalError('msg')
      oe.cause = 'cause'
      expect(() => handleAsyncError(oe)).to.throw('cause')
    })
  })
  describe('validateOptions', function () {
    it('should throw without batchSize', function () {
      let options: IConsumeQueueOptions<any, any> = {
        batchSize: null
      }
      assert.throws(() => QueueConsumer.validateOptions(options))
    })
    it('should throw with enableBatchProcessing and not handleMessageBatch', function () {
      let options: IConsumeQueueOptions<any, any> = {
        handleMessageBatch: null,
        enableBatchProcessing: true,
        batchSize: 1
      }
      assert.throws(() => QueueConsumer.validateOptions(options))
    })
    it('should default batchConcurrency to batchSize', function () {
      let options: IConsumeQueueOptions<any, any> = {
        handleMessageBatch: () => { throw '' },
        enableBatchProcessing: true,
        batchSize: 1
      }
      options = QueueConsumer.validateOptions(options)
      expect(options.batchConcurrency).eq(options.batchSize)
    })
    it('should accept batchConcurrency number', function () {
      let options: IConsumeQueueOptions<any, any> = {
        handleMessageBatch: () => { throw '' },
        enableBatchProcessing: true,
        batchSize: 1,
        batchConcurrency: 2
      }
      options = QueueConsumer.validateOptions(options)
      expect(options.batchConcurrency).eq(2)
    })
  })
  describe('consume', function () {
    it('should return a promise', function () {
      let options: IConsumeQueueOptions<any, any> = {
        handleMessage: () => { throw '' },
        batchSize: 1
      }
      let promise = subject.consume(options)
      expect(promise.then).to.be.a('function')
    })
    describe('when enableBatchProcessing is false', function () {
      let handleMessage: sinon.SinonStub = null
      let options: IConsumeQueueOptions<any, any> = null
      let emptyEvents = 0
      beforeEach(function () {
        handleMessage = sinon.stub()
        options = {
          handleMessage,
          batchSize: 1,
          enableBatchProcessing: false
        }
        emptyEvents = 0
        subject.on('empty', () => { emptyEvents++ })
      })
      it('should run once if consumeUntil => true permanantly but queue is empty', function () {
        queueService.getMessages.resolves(null)
        options.consumeUntil = sinon.stub().returns(true)
        let promise = subject.consume(options)
        return promise.then(function () {
          expect(queueService.getMessages, 'getMessages').to.have.callCount(1)
          expect(queueService.getMessages, 'getMessages').to.have.been.calledWith(options.batchSize)
          expect(queueService.deleteMessage, 'deleteMessage').to.have.callCount(0)
          expect(handleMessage, 'handleMessage').to.have.callCount(0)
          expect(emptyEvents, 'emptyEvents').to.be.above(0)
        })
      })
      it('should emit any message_processed_error', function (done) {
        this.timeout(5000)
        let msg: IQueueMessage<any> = { Id: Faker.random.uuid() }
        let expectedError = new Error(Faker.random.uuid())
        queueService.getMessages.onCall(0).resolves([msg])
        handleMessage.onCall(0).rejects(expectedError)
        queueService.getMessages.onCall(1).resolves(null)
        options.consumeUntil = sinon.stub().returns(true)
        let expectations = function (eventError: any, promiseError: any) {
          console.log('expectations', arguments)
          Promise.try(() => {
            expect(eventError).to.be.eq(expectedError)
            expect(promiseError).to.be.eq(expectedError)
          }).asCallback(done)
        }
        let curried = _.curry(expectations)
        subject.once(QueueConsumer.Events.message_processed_error, (evt: IQueueConsumerEvent<any, any>) => {
          console.log('message_processed_error', evt)
          curried = curried(evt.err)
        })
        subject.consume(options)
          .then(assert.fail)
          .catch(err => {
            console.error('catch', err)
            curried = curried(err)
          })
      })
      it('should emit once if consumeUntil => true and queue is not empty', function () {
        let msg: IQueueMessage<any> = { Id: Faker.random.uuid() }
        queueService.getMessages.onCall(0).resolves([msg])
        handleMessage.onCall(0).resolves(true)
        queueService.deleteMessage.onCall(0).resolves(true)
        queueService.getMessages.onCall(1).resolves(null)
        options.consumeUntil = sinon.stub().returns(true)
        let promise = subject.consume(options)
        return promise.then(function () {
          expect(queueService.getMessages, 'getMessages').to.have.callCount(1)
          expect(handleMessage, 'handleMessage').to.have.callCount(1)
          expect(handleMessage, 'handleMessage').to.have.been.calledWith(msg)
          expect(queueService.deleteMessage, 'deleteMessage').to.have.callCount(1)
          expect(queueService.deleteMessage, 'deleteMessage').to.have.been.calledWith(msg)
          expect(options.consumeUntil).to.have.callCount(1)
          expect(emptyEvents).to.be.eq(0)
        })
      })
      it('should process null or undefined messages', function () {
        queueService.getMessages.onCall(0).resolves([null])
        handleMessage.onCall(0).resolves(true)
        queueService.deleteMessage.onCall(0).resolves(true)
        queueService.getMessages.onCall(1).resolves(null)
        options.consumeUntil = sinon.stub().returns(true)
        let promise = subject.consume(options)
        return promise.then(function () {
          expect(queueService.getMessages, 'getMessages').to.have.callCount(1)
          expect(handleMessage, 'handleMessage').to.have.callCount(0)
          expect(queueService.deleteMessage, 'deleteMessage').to.have.callCount(0)
          expect(options.consumeUntil).to.have.callCount(1)
          expect(emptyEvents).to.be.eq(0)
        })
      })
      it('should emit any message_deleted_error', function (done) {
        let msg: IQueueMessage<any> = { Id: Faker.random.uuid() }
        let expectedError = new Error(Faker.random.uuid())
        queueService.getMessages.onCall(0).resolves([msg])
        handleMessage.onCall(0).resolves(true)
        queueService.getMessages.onCall(1).resolves(null)
        queueService.deleteMessage.rejects(expectedError)
        options.consumeUntil = sinon.stub().returns(true)
        let expectations = function (eventError: any, promiseError: any) {
          Promise.try(() => {
            expect(eventError).to.be.eq(expectedError)
            expect(promiseError).to.be.eq(expectedError)
          }).asCallback(done)
        }
        let curried = _.curry(expectations)
        subject.once(QueueConsumer.Events.message_deleted_error, (evt: IQueueConsumerEvent<any, any>) => {
          curried = curried(evt.err)
        })
        subject.consume(options)
          .then(assert.fail)
          .catch(err => {
            console.error('catch', err)
            curried = curried(err)
          })
      })
    })
    describe('when enableBatchProcessing is on', function () {
      let handleMessageBatch: sinon.SinonStub = null
      let options: IConsumeQueueOptions<any, any> = null
      let emptyEvents = 0
      beforeEach(function () {
        handleMessageBatch = sinon.stub()
        options = {
          handleMessageBatch: handleMessageBatch,
          batchSize: 5,
          enableBatchProcessing: true
        }
        emptyEvents = 0
        subject.on('empty', () => { emptyEvents++ })
      })
      it('should run once if consumeUntil => true permanantly but queue is empty', function () {
        queueService.getMessages.resolves(null)
        options.consumeUntil = sinon.stub().returns(true)
        let promise = subject.consume(options)
        return promise.then(function () {
          expect(queueService.getMessages, 'getMessages').to.have.callCount(1)
          expect(queueService.getMessages, 'getMessages').to.have.been.calledWith(options.batchSize)
          expect(queueService.deleteMessages, 'deleteMessages').to.have.callCount(0)
          expect(handleMessageBatch, 'handleMessageBatch').to.have.callCount(0)
          expect(emptyEvents, 'emptyEvents').to.be.above(0)
        })
      })
      it('should run once if consumeUntil => true and queue is not empty', function () {
        let messages = [genMsg(), genMsg(), genMsg()]
        queueService.getMessages.onCall(0).resolves(messages)
        handleMessageBatch.onCall(0).resolves(true)
        queueService.deleteMessages.onCall(0).resolves(true)
        queueService.getMessages.onCall(1).resolves(null)
        let consumeUntil = sinon.stub().returns(true)
        options.consumeUntil = consumeUntil
        let promise = subject.consume(options)
        return promise.then(function () {
          expect(queueService.getMessages, 'getMessages').to.have.callCount(1)
          expect(handleMessageBatch, 'handleMessageBatch').to.have.callCount(1)
          expect(handleMessageBatch, 'handleMessageBatch').to.have.been.calledWith(messages)
          expect(queueService.deleteMessages, 'deleteMessages').to.have.callCount(1)
          expect(queueService.deleteMessages, 'deleteMessages').to.have.been.calledWith(messages)
          expect(consumeUntil).to.have.callCount(1)
          expect(emptyEvents).to.be.eq(0)
        })
      })
      it('should emit any messages_processed_error', function (done) {
        let msg: IQueueMessage<any> = { Id: Faker.random.uuid() }
        let expectedError = new Error(Faker.random.uuid())
        queueService.getMessages.onCall(0).resolves([msg])
        handleMessageBatch.onCall(0).rejects(expectedError)
        queueService.getMessages.onCall(1).resolves(null)
        options.consumeUntil = sinon.stub().returns(true)
        let expectations = function (eventError: any, promiseError: any) {
          Promise.try(() => {
            expect(eventError).to.be.eq(expectedError)
            expect(promiseError).to.be.eq(expectedError)
          }).asCallback(done)
        }
        let curried = _.curry(expectations)
        subject.once(QueueConsumer.Events.messages_processed_error, (evt: IQueueConsumerEvent<any, any>) => {
          curried = curried(evt.err)
        })
        subject.consume(options)
          .then(assert.fail)
          .catch(err => {
            console.error('catch', err)
            curried = curried(err)
          })
      })
      it('should emit any messages_deleted_error', function (done) {
        let msg: IQueueMessage<any> = { Id: Faker.random.uuid() }
        let expectedError = new Error(Faker.random.uuid())
        queueService.getMessages.onCall(0).resolves([msg])
        handleMessageBatch.onCall(0).resolves(true)
        queueService.getMessages.onCall(1).resolves(null)
        queueService.deleteMessages.rejects(expectedError)
        options.consumeUntil = sinon.stub().returns(true)
        let expectations = function (eventError: any, promiseError: any) {
          Promise.try(() => {
            expect(eventError).to.be.eq(expectedError)
            expect(promiseError).to.be.eq(expectedError)
          }).asCallback(done)
        }
        let curried = _.curry(expectations)
        subject.once(QueueConsumer.Events.messages_deleted_error, (evt: IQueueConsumerEvent<any, any>) => {
          curried = curried(evt.err)
        })
        subject.consume(options)
          .then(assert.fail)
          .catch(err => {
            console.error('catch', err)
            curried = curried(err)
          })
      })
      it('should emit any and message_deleted and messages_delete_error but not break on individuals', function (done) {
        let messages = [genMsg(), genMsg()]
        queueService.getMessages.onCall(0).resolves(messages)
        handleMessageBatch.onCall(0).resolves(true)
        queueService.getMessages.onCall(1).resolves(null)
        let expectedMessageDeletedError = new Error(messages[1].Id)
        let deleteMessagesResult = {
          deletions: [messages[0]],
          failures: [_.assign(messages[1], { Error: expectedMessageDeletedError })]
        } as IDeleteMessagesResult
        queueService.deleteMessages.resolves(deleteMessagesResult)
        options.consumeUntil = sinon.stub().returns(true)
        let expectations = function (messageDeleted: any, messageDeletedError: any, promiseResult: any) {
          Promise.try(() => {
            expect(messageDeleted.Id, 'message_deleted.message.Id').to.be.equal(messages[0].Id)
            expect(messageDeletedError, 'message_deleted.err').to.be.eq(expectedMessageDeletedError)
            expect(promiseResult).to.be.ok
          }).asCallback(done)
        }
        let curried = _.curry(expectations)
        subject.once(QueueConsumer.Events.message_deleted, (evt: IQueueConsumerEvent<any, any>) => {
          curried = curried(evt.message)
        })
        subject.once(QueueConsumer.Events.message_deleted_error, (evt: IQueueConsumerEvent<any, any>) => {
          curried = curried(evt.err)
        })
        subject.consume(options)
          .then((result) => {
            curried = curried(result)
          })
          .catch(assert.fail)
      })
    })
  })
})
