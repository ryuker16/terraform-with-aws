/// <reference types="mocha" />
/// <reference types="sinon-as-promised" />

import { expect, use } from 'chai'
import { LambdaHandler, Context } from '../../src/aws/lambda'
import * as sinon from 'sinon'
import * as sinonChai from 'sinon-chai'
use(sinonChai)
import 'sinon-as-promised'
import * as Faker from 'faker'
import * as _ from 'lodash'
import * as AWS from 'aws-sdk'
let AwsRequest = function (stub: any) {
  return {
    promise: stub,
    send: stub
  }
}
class MyLambdaHandler extends LambdaHandler<any> {
}
describe('lambdaHandler', function () {
  it('should export class', function () {
    expect(LambdaHandler).to.be.a('function')
  })
  describe('constructor', function () {
    it('should throw without AWS.Lambda', function () {
      expect(() => {
        return new MyLambdaHandler(new AWS.S3() as any, null)
      }).to.throw(TypeError)
      expect(() => {
        return new MyLambdaHandler(null, null)
      }).to.throw(TypeError)
    })
    it('should throw without a LambdaContext', function () {
      expect(() => {
        return new MyLambdaHandler(new AWS.Lambda(), null)
      }).to.throw(TypeError)
    })
    it('should not throw with Lambda & LambdaContext', function () {
      expect(() => {
        return new MyLambdaHandler(new AWS.Lambda(), {} as Context)
      }).to.not.throw()
    })
  })
  describe('methods', function () {
    let lambdaContext: Context = null
    let subject: MyLambdaHandler = null
    let lambdaStub: any = null
    let expectedError: Error = null
    beforeEach(function () {
      let fn = () => true
      lambdaStub = sinon.stub({
        invoke: fn
      })
      lambdaContext = {
        awsRequestId: Faker.random.uuid(),
        functionName: Faker.name.firstName(),
        functionVersion: Faker.random.uuid(),
        invokedFunctionArn: Faker.random.uuid(),
        memoryLimitInMB: Faker.random.number(),
        callbackWaitsForEmptyEventLoop: Faker.random.boolean(),
        logGroupName: Faker.name.firstName(),
        logStreamName: Faker.name.firstName(),
        getRemainingTimeInMillis: sinon.stub(),
        log: sinon.stub(),
        fail: sinon.stub(),
        succeed: sinon.stub()
      }
      expectedError = new Error(Faker.random.uuid())
      subject = new MyLambdaHandler(lambdaStub, lambdaContext)
    })
    describe('selfInvokeAsync', function () {
      const withoutPayload = sinon.match(function (params: any) {
        return !_.has(params, 'Payload')
      })
      let requiredParams: sinon.SinonMatcher = null
      beforeEach(function () {
        requiredParams = sinon.match.has('FunctionName', lambdaContext.functionName)
          .and(sinon.match.has('InvocationType', 'Event'))
      })
      it('should default self FunctionName:functionName, InvocationType:Event', function () {
        lambdaStub.invoke.returns(AwsRequest(sinon.stub().rejects(expectedError)))
        return subject.selfInvokeAsync()
          .then(expect.fail)
          .catch(err => {
            expect(err).to.be.eq(expectedError)
            expect(lambdaStub.invoke).to.have.been.calledWith(requiredParams)
          })
      })
      it('should not stringify event as Payload when falsy', function () {
        lambdaStub.invoke.returns(AwsRequest(sinon.stub().rejects(expectedError)))
        let event: null = null
        return subject.selfInvokeAsync(event)
          .then(expect.fail)
          .catch(err => {
            expect(err).to.be.eq(expectedError)
            expect(lambdaStub.invoke).to.have.been.calledWith(requiredParams.and(withoutPayload))
          })
      })
      it('should stringify event as Payload FunctionName:self, InvocationType:Event', function () {
        lambdaStub.invoke.returns(AwsRequest(sinon.stub().rejects(expectedError)))
        let event = { foo: Faker.random.uuid() }
        return subject.selfInvokeAsync(event)
          .then(expect.fail)
          .catch(err => {
            expect(err).to.be.eq(expectedError)
            expect(lambdaStub.invoke).to.have.been.calledWith(
              requiredParams.and(sinon.match.has('Payload', JSON.stringify(event)))
            )
          })
      })
      it('should take overrides from invokeParams', function () {
        lambdaStub.invoke.returns(AwsRequest(sinon.stub().rejects(expectedError)))
        let event = { foo: Faker.random.uuid() }
        return subject.selfInvokeAsync(event, { InvocationType: 'RequestResponse' } as any)
          .then(expect.fail)
          .catch(err => {
            expect(err).to.be.eq(expectedError)
            expect(lambdaStub.invoke).to.have.been.calledWith(
              sinon.match.has('Payload', JSON.stringify(event))
                .and(sinon.match.has('InvocationType', 'RequestResponse'))
            )
          })
      })
    })
  })
})
