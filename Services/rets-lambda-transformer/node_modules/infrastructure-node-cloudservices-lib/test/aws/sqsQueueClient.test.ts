/// <reference types="mocha" />
/// <reference types="sinon-as-promised" />

import { expect, assert, use } from 'chai'
import { IQueueMessage } from '../../src/queues'
import { SQSQueueClient } from '../../src/aws/queues'
import * as sinon from 'sinon'
import * as sinonChai from 'sinon-chai'
use(sinonChai)
import 'sinon-as-promised'
import * as Faker from 'faker'
import * as _ from 'lodash'
import * as AWS from 'aws-sdk'
let AwsRequest = function (stub: any) {
  return {
    promise: stub,
    send: stub
  }
}
const genMessage = function () {
  return {
    MessageId: Faker.random.uuid(),
    ReceiptHandle: Faker.random.uuid(),
    Body: JSON.stringify({ 'prop': Faker.random.uuid() })
  } as AWS.SQS.Types.Message
}
const genSqsMessages = function (num: number) {
  let messages: AWS.SQS.Types.Message[] = []
  for (let i = 0; i < num; i++) {
    messages.push(genMessage())
  }
  return messages
}
describe('SQSQueueClient', function () {
  it('should export class', function () {
    expect(SQSQueueClient).to.be.a('function')
  })
  describe('constructor', function () {
    it('should throw without client', function () {
      expect(() => {
        return new SQSQueueClient(null)
      }).to.throw(TypeError)
    })
    it('should throw without an AWS.SQS like client', function () {
      expect(() => {
        return new SQSQueueClient({} as any)
      }).to.throw(TypeError)
    })

    it('should throw without an AWS.SQS like client', function () {
      expect(() => {
        return new SQSQueueClient({ receiveMessage: _.noop } as any)
      }).not.to.throw(TypeError)
    })
    it('should construct with an AWS.SQS client', function () {
      expect(() => {
        return new SQSQueueClient(sinon.stub(new AWS.SQS()) as any, 'some value')
      }).to.not.throw
    })
  })
  describe('mapMessage', function () {
    it('maps Id, Handle, and Body as JSON.parse', function () {
      let body = { foo: 'bar' }
      let sqsMessage = {
        MessageId: Faker.random.uuid(),
        ReceiptHandle: Faker.random.uuid(),
        Body: JSON.stringify(body)
      }
      let msg = SQSQueueClient.mapMessage(sqsMessage as AWS.SQS.Types.Message)
      expect(msg.Id).to.be.eq(sqsMessage.MessageId)
      expect(msg.Handle).to.be.eq(sqsMessage.ReceiptHandle)
      expect(msg.Data).to.deep.eq(body)
    })
  })
  describe('getMessage', () => {
    let sqsStub: any = null
    let sut: SQSQueueClient = null
    let queueUrl = Faker.random.uuid()
    beforeEach(() => {
      sqsStub = sinon.stub(new AWS.SQS())
      queueUrl = Faker.random.uuid()
      sut = new SQSQueueClient(sqsStub, queueUrl)
    })
    it('should call SQS receiveMessage with default QueueUrl', () => {
      let expectedError = new Error('abc')
      sqsStub.receiveMessage.returns(AwsRequest(sinon.stub().rejects(expectedError)))
      return sut.getMessage()
        .then(assert.fail)
        .catch((err) => {
          console.log(err.cause)
          expect(err).to.be.eq(expectedError)
          expect(sqsStub.receiveMessage).to.have.been.calledWith(sinon.match.has('QueueUrl', queueUrl))
        })
    })
    it('should call SQS receiveMessage with supplied { url: QueueUrl }', () => {
      let expectedError = new Error('abc')
      let expectedUrl = Faker.random.uuid()
      sqsStub.receiveMessage.returns(AwsRequest(sinon.stub().rejects(expectedError)))
      return sut.getMessage({ url: expectedUrl })
        .then(assert.fail)
        .catch(() => {
          expect(sqsStub.receiveMessage).to.have.been.calledWith(sinon.match.has('QueueUrl', expectedUrl))
        })
    })
    it('should reject if SQS receiveMessage rejects', () => {
      let expectedError = new Error(queueUrl)
      sqsStub.receiveMessage.returns(AwsRequest(sinon.stub().rejects(expectedError)))
      return sut.getMessage()
        .then(assert.fail)
        .catch(err => expect(err).to.be.eq(expectedError))
    })
    it('should map Messages[0] if SQS receiveMessage resolves', () => {
      let result: AWS.SQS.Types.ReceiveMessageResult = {
        Messages: [genMessage()]
      }
      sqsStub.receiveMessage.returns(AwsRequest(sinon.stub().resolves(result)))
      return sut.getMessage()
        .then(msg => {
          expect(msg.Id).to.be.eq(result.Messages[0].MessageId)
        })
    })
  })
  describe('getMessages', () => {
    let sqsStub: any = null
    let sut: SQSQueueClient = null
    let queueUrl = Faker.random.uuid()
    beforeEach(() => {
      sqsStub = sinon.stub(new AWS.SQS())
      queueUrl = Faker.random.uuid()
      sut = new SQSQueueClient(sqsStub, queueUrl)
    })
    it('should call SQS receiveMessage with batchSize: MaxNumberOfMessages', () => {
      let expectedError = new Error('abc')
      let batchSize = Faker.random.number()
      sqsStub.receiveMessage.returns(AwsRequest(sinon.stub().rejects(expectedError)))
      return sut.getMessages(batchSize)
        .then(assert.fail)
        .catch((err) => {
          expect(err).to.be.eq(expectedError)
          expect(sqsStub.receiveMessage).to.have.been.calledWith(sinon.match.has('MaxNumberOfMessages', batchSize))
        })
    })
    it('should map Messages if SQS receiveMessage resolves', () => {
      let result: AWS.SQS.Types.ReceiveMessageResult = {
        Messages: [genMessage(), genMessage()]
      }
      sqsStub.receiveMessage.returns(AwsRequest(sinon.stub().resolves(result)))
      return sut.getMessages(Faker.random.number())
        .then(messages => {
          result.Messages.forEach((msg, index) => {
            expect(messages[index].Id).to.be.eq(msg.MessageId)
          })
        })
    })
  })
  describe('deleteMessage', () => {
    let sqsStub: any = null
    let sut: SQSQueueClient = null
    let queueUrl = Faker.random.uuid()
    beforeEach(() => {
      sqsStub = sinon.stub(new AWS.SQS())
      queueUrl = Faker.random.uuid()
      sut = new SQSQueueClient(sqsStub, queueUrl)
    })
    it('should call SQS deleteMessage', () => {
      let expectedError = new Error('abc')
      let msg = SQSQueueClient.mapMessage(genMessage())
      sqsStub.deleteMessage.returns(AwsRequest(sinon.stub().rejects(expectedError)))
      return sut.deleteMessage(msg)
        .then(assert.fail)
        .catch((err) => {
          expect(err).to.be.eq(expectedError)
          expect(sqsStub.deleteMessage).to.have.been.calledWith(sinon.match.has('ReceiptHandle', msg.Handle))
        })
    })
  })
  describe('deleteMessages', () => {
    let sqsStub: any = null
    let sut: SQSQueueClient = null
    let queueUrl = Faker.random.uuid()
    beforeEach(() => {
      sqsStub = sinon.stub(new AWS.SQS())
      queueUrl = Faker.random.uuid()
      sut = new SQSQueueClient(sqsStub, queueUrl)
    })
    it('should call SQS deleteMessageBatch', () => {
      let expectedError = new Error('abc')
      let num = Faker.random.number({ min: 1, max: 10 })
      let msgs = _.map(genSqsMessages(num), SQSQueueClient.mapMessage)
      sqsStub.deleteMessageBatch.returns(AwsRequest(sinon.stub().rejects(expectedError)))
      return sut.deleteMessages(msgs)
        .then(assert.fail)
        .catch((err) => {
          expect(err).to.be.eq(expectedError)
          expect(sqsStub.deleteMessageBatch).to.have.been.called
        })
    })
    it('should map Id and Handle for each message to SQS deleteMessageBatch', () => {
      let expectedError = new Error('abc')
      let num = Faker.random.number({ min: 1, max: 10 })
      let msgs = _.map(genSqsMessages(num), SQSQueueClient.mapMessage) as IQueueMessage<any>[]
      sqsStub.deleteMessageBatch.returns(AwsRequest(sinon.stub().rejects(expectedError)))
      return sut.deleteMessages(msgs)
        .then(assert.fail)
        .catch((err) => {
          expect(err).to.be.eq(expectedError)
          let params = sqsStub.deleteMessageBatch.getCall(0).args[0]
          for (let i = 0; i < num; i++) {
            expect(params.Entries[i].Id, i + ' Id').to.be.equal(msgs[i].Id)
            expect(params.Entries[i].ReceiptHandle, i + 'Id').to.be.equal(msgs[i].Handle)
          }
        })
    })
    it('should map deletions and failures from deleteMessageBatch', () => {
      let sqsMessages = genSqsMessages(2)
      let expectedResult: any = {
        Successful: [_.extend(sqsMessages[0], { Id: sqsMessages[0].MessageId })],
        Failed: [_.extend(sqsMessages[1], { Id: sqsMessages[1].MessageId })]
      }
      let msgs = _.map(sqsMessages, SQSQueueClient.mapMessage) as IQueueMessage<any>[]
      sqsStub.deleteMessageBatch.returns(AwsRequest(sinon.stub().resolves(expectedResult)))
      expect(_.map(null, () => { throw '' }), '_.map').to.have.lengthOf(0)
      expect(Array.isArray(_.map(undefined, () => true))).to.be.eq(true)
      return sut.deleteMessages(msgs)
        .then((result) => {
          expect(result.deletions).to.have.lengthOf(1)
          expect(result.failures).to.have.lengthOf(1)
        })
    })
  })
})
