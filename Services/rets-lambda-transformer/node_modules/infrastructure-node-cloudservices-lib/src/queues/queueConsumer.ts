import { EventEmitter } from 'events'
import { doUntil } from 'async'
import { IQueueMessage, IQueueService, IQueueConsumer, IConsumeQueueOptions } from './interfaces'
import * as BPromise from 'bluebird'
import * as _ from 'lodash'

declare module 'bluebird' {
  interface OperationalError {
    cause: any
    isOperational: boolean
  }
}
function isOperationalError(err?: any): err is BPromise.OperationalError {
  return err && err instanceof BPromise.OperationalError && err.isOperational === true
}
export function handleAsyncError(err: BPromise.OperationalError | Error) {
  throw isOperationalError(err) ? err.cause : err
}
export class QueueConsumer<TMessage, TResult>
  extends EventEmitter
  implements IQueueConsumer<TMessage, TResult> {
  static Events = {
    'messages_received': 'messages_received',
    'messages_processed': 'messages_processed',
    'messages_processed_error': 'messages_processed_error',
    'message_processed': 'message_processed',
    'message_processed_error': 'message_processed_error',
    'message_deleted': 'message_deleted',
    'message_deleted_error': 'message_deleted_error',
    'messages_deleted_error': 'messages_deleted_error'
  }
  constructor(
    private queueService: IQueueService) {
    super()
    if (!queueService) {
      throw new TypeError('queueService')
    }
  }

  static validateOptions<TMessage, TResult>(options: IConsumeQueueOptions<TMessage, TResult>) {
    if (!options.batchSize) {
      throw new TypeError('batchSize')
    }
    if (options.enableBatchProcessing && typeof options.handleMessageBatch !== 'function') {
      throw new TypeError('enableBatchProcessing requires handleMessageBatch')
    }
    if (!options.batchConcurrency) {
      options.batchConcurrency = options.batchSize
    }
    return options
  }
  consume(options: IConsumeQueueOptions<TMessage, TResult>): BPromise<any> {
    options = QueueConsumer.validateOptions(options)
    let isDone = false
    this.once('empty', () => {
      isDone = true
    })
    let doUntilTest = function () {
      return isDone || (typeof options.consumeUntil === 'function' && options.consumeUntil())
    }
    return BPromise.fromCallback(callback => {
      const fn = (callback: any) => BPromise.resolve(this.consumeMessages(options)).asCallback(callback)
      doUntil(fn, doUntilTest, callback)
    }).error(handleAsyncError)
  }
  private consumeMessages(options: IConsumeQueueOptions<TMessage, TResult>) {
    return BPromise.bind(this)
      .then(() => this.queueService.getMessages<TMessage>(options.batchSize))
      .tap((messages) => this.emit(QueueConsumer.Events.messages_received, { messages }))
      .then<any>((messages) => {
        if (messages && messages.length) {
          if (options.enableBatchProcessing) {
            return this.processMessageBatch(messages, options)
          } else {
            return BPromise.map(
              messages,
              (message) => this.processMessage(message, options),
              { concurrency: options.batchConcurrency }
            )
          }
        } else {
          this.emit('empty')
        }
      })
  }
  private processMessageBatch(messages: IQueueMessage<TMessage>[], options: IConsumeQueueOptions<TMessage, TResult>) {
    return BPromise.bind(this)
      .then(() => BPromise.resolve(options.handleMessageBatch(messages)))
      .tap((result) => this.emit(QueueConsumer.Events.messages_processed, { result, messages }))
      .catch(err => {
        this.emit(QueueConsumer.Events.messages_processed_error, { messages, err })
        throw err
      })
      .then(() => this.deleteMessageBatch(messages))
  }
  private processMessage(message: IQueueMessage<TMessage>, options: IConsumeQueueOptions<TMessage, TResult>) {
    if (message) {
      return BPromise.bind(this)
        .then(() => BPromise.resolve(options.handleMessage(message)))
        .tap((result) => this.emit(QueueConsumer.Events.message_processed, { result, message }))
        .catch((err) => {
          this.emit(QueueConsumer.Events.message_processed_error, { message, err })
          throw err
        })
        .then(() => this.deleteMessage(message))
    }
  }
  private deleteMessageBatch(messages: IQueueMessage<TMessage>[]) {
    return BPromise.bind(this)
      .then(() => this.queueService.deleteMessages(messages))
      .then((result) => {
        _.forEach(result.deletions || [], (deletion) => {
          this.emit(QueueConsumer.Events.message_deleted, { message: deletion })
        })
        _.forEach(result.failures || [], (failure) => {
          this.emit(QueueConsumer.Events.message_deleted_error, { err: failure.Error, failure })
        })
        return result
      })
      .catch((err) => {
        this.emit(QueueConsumer.Events.messages_deleted_error, { messages, err })
        throw err
      })
  }
  private deleteMessage(message: IQueueMessage<any>) {
    return BPromise.bind(this)
      .then(() => this.queueService.deleteMessage(message))
      .tap(() => this.emit(QueueConsumer.Events.message_deleted, { message }))
      .catch((err) => {
        this.emit(QueueConsumer.Events.message_deleted_error, { message, err })
        throw err
      })
  }
}
