/// <reference types="bluebird" />
/// <reference types="node" />
import * as BPromise from 'bluebird';
import { EventEmitter } from 'events';
export interface IQueueMessage<T> {
    Id?: string;
    Handle?: string;
    Data?: T;
}
export interface IQueueMessageOf<TMessage, TProviderMessage> extends IQueueMessage<TMessage> {
    ProviderMessage?: TProviderMessage;
}
export interface IQueueClient {
    getMessage<T>(options?: IQueueOptions): BPromise<IQueueMessage<T>>;
    getMessages<T>(batchSize: number, options?: IQueueOptions): BPromise<IQueueMessage<T>[]>;
    deleteMessage(message: IQueueMessage<any>, options?: IQueueOptions): BPromise<any>;
    deleteMessages(message: IQueueMessage<any>, options?: IQueueOptions): BPromise<IDeleteMessagesResult>;
}
export interface IDeleteMessagesResult {
    deletions?: {
        Id: string;
    }[];
    failures?: {
        Id: string;
        Error?: Error;
    }[];
}
export interface IQueueClientOf<TProviderMessage> extends IQueueClient {
    getMessage<T>(): BPromise<IQueueMessageOf<T, TProviderMessage>>;
    getMessages<T>(batchSize: number): BPromise<IQueueMessageOf<T, TProviderMessage>[]>;
    deleteMessage(message: IQueueMessage<any>): BPromise<any>;
}
export interface IQueueOptions {
    url?: string;
    maxNumberOfMessages?: number;
    WaitTimeSeconds?: number;
    visibilityTimeout?: number;
}
export interface IQueueService {
    getMessage<T>(options?: IQueueOptions): BPromise<IQueueMessage<T>>;
    getMessages<T>(batchSize: number, options?: IQueueOptions): BPromise<IQueueMessage<T>[]>;
    deleteMessage(message: IQueueMessage<any>, options?: IQueueOptions): BPromise<any>;
    deleteMessages(messages: IQueueMessage<any>[], options?: IQueueOptions): BPromise<IDeleteMessagesResult>;
}
export interface IQueueConsumer<TMessage, TResult> extends EventEmitter {
    consume(options: IConsumeQueueOptions<TMessage, TResult>): BPromise<boolean>;
}
export interface IConsumeQueueOptions<TMessage, TResult> {
    handleMessage?: (msg: IQueueMessage<TMessage>) => BPromise<TResult>;
    handleMessageBatch?: (msg: IQueueMessage<TMessage>[]) => BPromise<TResult>;
    batchSize: number;
    batchConcurrency?: number;
    enableBatchProcessing?: boolean;
    consumeUntil?: () => boolean;
}
export interface IQueueConsumerEvent<TMessage, TResult> {
    err?: Error;
    message?: IQueueMessage<TMessage>;
    messages?: IQueueMessage<TMessage>[];
    result?: TResult;
}
