import { EventEmitter } from 'events';
import { doUntil } from 'async';
import * as BPromise from 'bluebird';
import * as _ from 'lodash';
function isOperationalError(err) {
    return err && err instanceof BPromise.OperationalError && err.isOperational === true;
}
export function handleAsyncError(err) {
    throw isOperationalError(err) ? err.cause : err;
}
export class QueueConsumer extends EventEmitter {
    constructor(queueService) {
        super();
        this.queueService = queueService;
        if (!queueService) {
            throw new TypeError('queueService');
        }
    }
    static validateOptions(options) {
        if (!options.batchSize) {
            throw new TypeError('batchSize');
        }
        if (options.enableBatchProcessing && typeof options.handleMessageBatch !== 'function') {
            throw new TypeError('enableBatchProcessing requires handleMessageBatch');
        }
        if (!options.batchConcurrency) {
            options.batchConcurrency = options.batchSize;
        }
        return options;
    }
    consume(options) {
        options = QueueConsumer.validateOptions(options);
        let isDone = false;
        this.once('empty', () => {
            isDone = true;
        });
        let doUntilTest = function () {
            return isDone || (typeof options.consumeUntil === 'function' && options.consumeUntil());
        };
        return BPromise.fromCallback(callback => {
            const fn = (callback) => BPromise.resolve(this.consumeMessages(options)).asCallback(callback);
            doUntil(fn, doUntilTest, callback);
        }).error(handleAsyncError);
    }
    consumeMessages(options) {
        return BPromise.bind(this)
            .then(() => this.queueService.getMessages(options.batchSize))
            .tap((messages) => this.emit(QueueConsumer.Events.messages_received, { messages }))
            .then((messages) => {
            if (messages && messages.length) {
                if (options.enableBatchProcessing) {
                    return this.processMessageBatch(messages, options);
                }
                else {
                    return BPromise.map(messages, (message) => this.processMessage(message, options), { concurrency: options.batchConcurrency });
                }
            }
            else {
                this.emit('empty');
            }
        });
    }
    processMessageBatch(messages, options) {
        return BPromise.bind(this)
            .then(() => BPromise.resolve(options.handleMessageBatch(messages)))
            .tap((result) => this.emit(QueueConsumer.Events.messages_processed, { result, messages }))
            .catch(err => {
            this.emit(QueueConsumer.Events.messages_processed_error, { messages, err });
            throw err;
        })
            .then(() => this.deleteMessageBatch(messages));
    }
    processMessage(message, options) {
        if (message) {
            return BPromise.bind(this)
                .then(() => BPromise.resolve(options.handleMessage(message)))
                .tap((result) => this.emit(QueueConsumer.Events.message_processed, { result, message }))
                .catch((err) => {
                this.emit(QueueConsumer.Events.message_processed_error, { message, err });
                throw err;
            })
                .then(() => this.deleteMessage(message));
        }
    }
    deleteMessageBatch(messages) {
        return BPromise.bind(this)
            .then(() => this.queueService.deleteMessages(messages))
            .then((result) => {
            _.forEach(result.deletions || [], (deletion) => {
                this.emit(QueueConsumer.Events.message_deleted, { message: deletion });
            });
            _.forEach(result.failures || [], (failure) => {
                this.emit(QueueConsumer.Events.message_deleted_error, { err: failure.Error, failure });
            });
            return result;
        })
            .catch((err) => {
            this.emit(QueueConsumer.Events.messages_deleted_error, { messages, err });
            throw err;
        });
    }
    deleteMessage(message) {
        return BPromise.bind(this)
            .then(() => this.queueService.deleteMessage(message))
            .tap(() => this.emit(QueueConsumer.Events.message_deleted, { message }))
            .catch((err) => {
            this.emit(QueueConsumer.Events.message_deleted_error, { message, err });
            throw err;
        });
    }
}
QueueConsumer.Events = {
    'messages_received': 'messages_received',
    'messages_processed': 'messages_processed',
    'messages_processed_error': 'messages_processed_error',
    'message_processed': 'message_processed',
    'message_processed_error': 'message_processed_error',
    'message_deleted': 'message_deleted',
    'message_deleted_error': 'message_deleted_error',
    'messages_deleted_error': 'messages_deleted_error'
};
