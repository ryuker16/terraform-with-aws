import * as _ from 'lodash';
import * as BPromise from 'bluebird';
export class SQSQueueClient {
    constructor(sqs, queueUrl) {
        this.sqs = sqs;
        this.queueUrl = queueUrl;
        if (!sqs) {
            throw new TypeError('sqs');
        }
        if (!_.isFunction(sqs.receiveMessage)) {
            throw new TypeError('sqs.receiveMessage');
        }
    }
    static mapMessage(msg) {
        return {
            Id: msg.MessageId,
            Handle: msg.ReceiptHandle,
            Data: JSON.parse(msg.Body),
            ProviderMessage: msg
        };
    }
    getMessage(options) {
        let params = {
            QueueUrl: this.getQueueUrl(options)
        };
        return BPromise.resolve(this.sqs.receiveMessage(params).promise())
            .then((result) => {
            let messages = _.map(result.Messages, (msg) => SQSQueueClient.mapMessage(msg));
            return _.first(messages);
        });
    }
    getMessages(batchSize, options) {
        let params = {
            QueueUrl: this.getQueueUrl(options),
            MaxNumberOfMessages: batchSize
        };
        return BPromise.resolve(this.sqs.receiveMessage(params).promise())
            .then((result) => {
            return _.map(result.Messages, SQSQueueClient.mapMessage);
        });
    }
    deleteMessage(message, options) {
        let params = {
            QueueUrl: this.getQueueUrl(options),
            ReceiptHandle: message.Handle
        };
        return BPromise.resolve(this.sqs.deleteMessage(params).promise());
    }
    deleteMessages(messages, options) {
        let params = {
            QueueUrl: this.getQueueUrl(options),
            Entries: _.map(messages, msg => {
                return {
                    Id: msg.Id,
                    ReceiptHandle: msg.Handle
                };
            })
        };
        return BPromise.resolve(this.sqs.deleteMessageBatch(params).promise())
            .then((result) => {
            let deletions = result.Successful;
            let failures = _.map(result.Failed, (failed) => {
                return {
                    Id: failed.Id,
                    Error: new Error(failed.Message)
                };
            });
            return { deletions, failures };
        });
    }
    getQueueUrl(options) {
        if (options && options.url) {
            return options.url;
        }
        return this.queueUrl;
    }
}
