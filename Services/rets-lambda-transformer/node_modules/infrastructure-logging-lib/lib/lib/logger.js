"use strict";
const BLogger = require("bunyan");
const os = require("os");
const uuid = require('uuid');
const _ = require("lodash");
const core_1 = require("./core");
const logentries_1 = require("./logentries");
const transforms_1 = require("./transforms");
const debug_1 = require("./debug");
// const ERROR_LEVELS = ['error', 'fatal']
const AUDIT_LEVELS = ['trace', 'debug', 'info', 'warn'];
/**
 * Custom Logger class with special log methods
 * Options available:
 *  - {string} name (required): the name of the Logger
 *  - {Object} context (optional): context attributes shared across all messages.
 *  - {boolean} autoContext (optional): if true, adds in generated context
 *      attributes based on system information.
 *  - {Array} streams (optional): bunyan style streams to be added to this Logger
 */
class Logger {
    constructor(appName, serviceName, context, implementation) {
        this.appName = appName;
        this.serviceName = serviceName;
        this.context = context || {};
        this.useAutoContext = false;
        this.autoContext = Logger._getAutoContext();
        this.bunyanLogger = createBunyanLogger(Logger.getLoggerName(appName, serviceName), implementation);
    }
    /**
     * Generates the bunyan name of the logger based on appName_serviceName
     * @return {string}
     */
    static getLoggerName(appName, serviceName) {
        return `${appName}_${serviceName}`;
    }
    /**
         * Generates the automatic context for a given logger.
         * @return {object} The generated context
         */
    static _getAutoContext() {
        return {
            'os': {
                'architecture': os.arch(),
                'hostname': os.hostname(),
                'platform': os.platform(),
                'release': os.release()
            }
        };
    }
    /**
     * Sends an audit message.
     * Allows for level to be specified as one of:
     *  - 'trace', 'debug', 'info' (default), 'warn'
     * @param {string} msg - log message
     * @param {enum} level - the log level to be used
     * @param {object} context - extra context associated with the individual log event
     */
    audit(msg, level, context) {
        level = AUDIT_LEVELS.indexOf(level) > -1 ? level : 'info';
        let enhancements = {
            'context': context || {},
            'eventType': 'audit'
        };
        enhancements = this._addCommonEnhancements(enhancements);
        this.bunyanLogger[level](enhancements, msg);
    }
    /**
     * Sends a boundary message.
     * @param {string} edge - indicates if this is the 'start' or 'end' of an event
     * @param {object} context - extra context associated with the individual log event
     */
    boundary(edge, context) {
        let enhancements = {
            'boundary': {
                'edge': edge
            },
            'context': context || {},
            'eventType': 'boundary'
        };
        enhancements = this._addCommonEnhancements(enhancements);
        this.bunyanLogger.info(enhancements, '');
    }
    /**
     * Sends an error event
     * @param {object} err - the error object
     * @param {object} context - extra context associated with the individual log event
     */
    error(err, context) {
        let enhancements = {
            'err': err,
            'context': context || {},
            'eventType': 'error'
        };
        enhancements = this._addCommonEnhancements(enhancements);
        this.bunyanLogger.error(enhancements);
    }
    /**
     * Sends a telemetry event that measures something about the code execution
     * @param {string} name - name of the aspect being measured
     * @param {enum} targetType - type of metric being targeted
     * @param {string} unit - the unit associated with the value
     * @param {any} value - value associate with this event
     * @param {object} context - extra context associated with the individual log event
     */
    telemetry(name, targetType, unit, value, context) {
        let enhancements = {
            'telemetry': {
                'name': name,
                'targetType': targetType,
                'unit': unit,
                'value': value
            },
            'context': context || {},
            'eventType': 'telemetry'
        };
        enhancements = this._addCommonEnhancements(enhancements);
        this.bunyanLogger.info(enhancements);
    }
    /**
     * Adds a bunyan style stream to send all log messages to
     * @param {bunyan Stream} stream The bunyan style stream to be added
     */
    addStream(stream) {
        // this.bunyanLogger.addStream(applyPostBunyanTransform(stream))
        this.bunyanLogger.addStream(stream);
    }
    /**
     * Enable or disable automatic host context gathering.
     * @param {boolean} autoContext - true to enable, false to disable
     */
    setAutoContext(useAutoContext) {
        this.useAutoContext = useAutoContext;
    }
    /**
     * Gets the name of this logger
     */
    getName() {
        return this.bunyanLogger.fields.name;
    }
    /**
     * Merge or append context information to Subsequent Logger calls
     * { context: {} } object
     */
    mergeContext(context) {
        this.context = _.merge(this.context, context);
    }
    /**
     * Reset context information to Subsequent Logger calls
     * { context: {} } object
     */
    setContext(context) {
        this.context = context;
    }
    /**
     * Adds enhancement data common to all event messages
     * @param {object} baseEnh - extra data associated with this specific event/type
     * @param {object} The result of the common enhancements merged with the base
     * enhancements
     */
    _addCommonEnhancements(baseEnh) {
        // Source objects are applied from left to right.
        // Once a property is set, additional values of the same property are ignored.
        let sharedContext = this.useAutoContext
            ? _.defaultsDeep({}, this.context, this.autoContext)
            : _.defaultsDeep({}, this.context);
        if (!sharedContext.correlationID) {
            sharedContext.correlationID = uuid.v1();
        }
        let defaultEnh = {
            type: this.appName,
            service: this.serviceName,
            context: sharedContext
        };
        let overEnh = {
            eventID: uuid.v1()
        };
        // Subsequent sources overwrite property assignments of previous sources.
        return _.merge(defaultEnh, baseEnh, overEnh);
    }
}
exports.Logger = Logger;
core_1.handleErrorsOnPublicMethods(Logger);
/**
 * Creates a bunyan Logger object with automatic kinesis stream and error
 * serializer.
 * @param {string} name The name to give the new bunyan Logger
 * @return {bunyan.Logger} The new bunyan Logger
 */
function createBunyanLogger(name, options) {
    let streams = [];
    if (process.env.DEBUG && String.prototype.includes.call(process.env.DEBUG, 'logginglib')) {
        streams.push({
            level: 'trace',
            stream: new debug_1.default()
        });
    }
    let serializers = { err: BLogger.stdSerializers['err'] };
    if (_.isObjectLike(options)) {
        if (_.isObjectLike(options.kinesis)) {
            streams.push(getKinesisBunyanStream(options.kinesis));
        }
        if (_.isObjectLike(options.logentries)) {
            streams.push(logentries_1.getLogEntriesBunyanStream(options.logentries));
        }
        if (_.isArray(options.streams)) {
            streams = streams.concat(options.streams);
        }
        if (_.isObjectLike(options.serializers)) {
            serializers = options.serializers;
        }
    }
    return BLogger.createLogger({ name, serializers, streams });
}
exports.createBunyanLogger = createBunyanLogger;
function getKinesisBunyanStream(options) {
    let stream = {
        level: options.level || 'info',
        stream: core_1.getKinesisLogStream(options),
        type: 'raw'
    };
    let kinesisBunyanStream = Logger.enablePostBunyanTransform
        ? transforms_1.applyPostBunyanTransform(stream)
        : stream;
    return kinesisBunyanStream;
}
