"use strict";
const stream_1 = require("stream");
const _ = require("lodash");
/**
 * Transform to turn JS object messages into kinesis PutRecords designed for
 * 'kinesis' library stream. Always has objectMode set to true.
 * Emits objects with
 *   Data: Base64 encoded JSON of object
 *   PartitionKey: unspecified but constant string
 */
class KinesifyTransform extends stream_1.Transform {
    constructor(options) {
        if (!_.isObject(options)) {
            throw new TypeError('KinesifyTransformOptions');
        }
        if (!_.isString(options.PartitionKey)) {
            throw new TypeError('PartitionKey');
        }
        options.objectMode = true;
        super(options);
        this.PartitionKey = options.PartitionKey;
    }
    _transform(obj, encoding, cb) {
        let json = JSON.stringify(obj);
        let base64 = new Buffer(json).toString('base64');
        cb(null, { Data: base64, PartitionKey: this.PartitionKey });
    }
}
exports.KinesifyTransform = KinesifyTransform;
/**
 * Transforms raw log records recieved from bunyan to fit Placester standard
 * log format.
 * Removes: 'v', 'pid', 'hostname' fields
 */
class PostBunyanTransform extends stream_1.Transform {
    /**
     * Constructs a new transform.
     * Options:
     *  - {boolean} raw: if true, returns raw JavaScript record object instead of JSON
     */
    constructor(options) {
        options = options || {};
        options.objectMode = true;
        super(options);
        this.raw = options.raw || false;
    }
    _transform(obj, endcoding, cb) {
        const toremove = ['v', 'pid', 'hostname'];
        let removed = _.omit(obj, toremove);
        if (this.raw) {
            cb(null, removed);
        }
        else {
            cb(null, JSON.stringify(removed));
        }
    }
}
exports.PostBunyanTransform = PostBunyanTransform;
/**
 * Takes a bunyan Stream object, and inserts a PostBunyanTransform
 * before the stream destination. Destination streams should be unaffected
 * except as the Transform molds objects passed through.
 * @param {object} bunyanStream following bunyan 'Stream' semantics
 *   bunyanStream.stream must be defined
 * @return {bunyan Stream} the bunyan Stream with the Transform applied
 */
function applyPostBunyanTransform(bunyanStream) {
    let transform = new PostBunyanTransform({
        raw: bunyanStream.type === 'raw'
    });
    transform.pipe(bunyanStream.stream);
    let newStream = _.clone(bunyanStream);
    newStream.stream = transform;
    return newStream;
}
exports.applyPostBunyanTransform = applyPostBunyanTransform;
