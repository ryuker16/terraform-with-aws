"use strict";
const Promise = require("bluebird");
const kinesis = Promise.promisifyAll(require('kinesis'));
const stream_1 = require("stream");
const transforms_1 = require("./transforms");
const _ = require("lodash");
// Set up the shared kinesisLogStream
function getKinesisLogStream(options) {
    if (!_.isObjectLike(options)) {
        throw new TypeError('EstablishKinesisStreamOptions');
    }
    let kt = new transforms_1.KinesifyTransform({ PartitionKey: options.PartitionKey });
    /* istanbul ignore else */
    if (process.env.NODE_ENV === 'test') {
        let testKinesisPassThrough = new stream_1.PassThrough({ objectMode: true });
        kt.pipe(testKinesisPassThrough);
    }
    else {
        let kinesisRawStream = establishKinesisStream(options);
        kt.pipe(kinesisRawStream);
    }
    return kt;
}
exports.getKinesisLogStream = getKinesisLogStream;
/**
 * Creates a stream that recieves JSON object messages and streams and sends
 * them to Kinesis. Ensures that the Kinesis stream has been created.
 * @param {object} cfg - Configuration object for the kinesis stream.
 *   Must have cfg.stream.name, cfg.stream.sharts, cfg.connection defined.
 */
function establishKinesisStream(cfg) {
    let streamConnection = _.assign({ name: cfg.stream.name }, cfg.connection);
    // Note: kinesis.stream is NOT asynchronous
    return kinesis.stream(streamConnection);
}
/**
 * Wraps a function decorator so wrappers produced by the decorator have the
 * same properties as the original function.
 * @param {function} decorator - a function that accepts a method and returns a
 * wrapped method.
 */
function fixDecorator(decorator) {
    return function (f) {
        let wrapper = decorator(f);
        let properties = Object.getOwnPropertyNames(f);
        for (let i = 0; i < properties.length; i++) {
            let prop = properties[i];
            if (f.hasOwnProperty(prop)) {
                Object.defineProperty(wrapper, prop, Object.getOwnPropertyDescriptor(f, prop));
            }
        }
        return wrapper;
    };
}
/**
 * Decorates f to handle uncaught Errors. Returned function behaves like f when
 * there no errors. When an Error is caught, returns the result of handler
 * called on the error. Based off Python decorator conventions.
 * @param {function} f - function to be decorated
 * @param {function} handler (optional) - called on any caught error.
 */
function handleErrors(f, handler) {
    handler = handler || function () { };
    function decorator(fn) {
        let wrapper = function () {
            try {
                return fn.apply(this, arguments);
            }
            catch (err) {
                return handler(err);
            }
        };
        return wrapper;
    }
    return fixDecorator(decorator)(f);
}
exports.handleErrors = handleErrors;
/**
 * Applies error handling decorator to all the given methods on the class's prototype.
 * @param {class} klass - the class whose methods will be decorated
 * @param {Array[string]} methods - the method names to be wrapped
 * @param {function} handler - function to be called on caught errors
 */
function handleErrorsOnMethods(klass, methods, handler) {
    for (let i = 0; i < methods.length; i++) {
        klass.prototype[methods[i]] = handleErrors(klass.prototype[methods[i]], handler);
    }
}
exports.handleErrorsOnMethods = handleErrorsOnMethods;
/**
 * Applies error handling decorator to all public (no leading '_') methods on a
 * class
 * @param {class} klass - the class whose methods will be decorated
 * @param {function} handler - function to be called on caught errors
 */
function handleErrorsOnPublicMethods(klass, handler) {
    let pNames = Object.getOwnPropertyNames(klass.prototype);
    let pubMethods = pNames.filter(function (pName) {
        return klass.prototype[pName] instanceof Function && pName[0] !== '_';
    });
    handleErrorsOnMethods(klass, pubMethods, handler);
}
exports.handleErrorsOnPublicMethods = handleErrorsOnPublicMethods;
