import { Transform } from 'stream'
import * as _ from 'lodash'
import * as bunyan from 'bunyan'

export interface KinesifyTransformOptions {
  PartitionKey?: string
  objectMode?: true
}

/**
 * Transform to turn JS object messages into kinesis PutRecords designed for
 * 'kinesis' library stream. Always has objectMode set to true.
 * Emits objects with
 *   Data: Base64 encoded JSON of object
 *   PartitionKey: unspecified but constant string
 */
export class KinesifyTransform extends Transform {

  public PartitionKey: string

  constructor(options: KinesifyTransformOptions) {
    if (!_.isObject(options)) {
      throw new TypeError('KinesifyTransformOptions')
    }
    if (!_.isString(options.PartitionKey)) {
      throw new TypeError('PartitionKey')
    }
    options.objectMode = true
    super(options)
    this.PartitionKey = options.PartitionKey
  }

  public _transform(obj, encoding, cb) {
    let json = JSON.stringify(obj)
    let base64 = new Buffer(json).toString('base64')
    cb(null, { Data: base64, PartitionKey: this.PartitionKey })
  }
}

/**
 * Transforms raw log records recieved from bunyan to fit Placester standard
 * log format.
 * Removes: 'v', 'pid', 'hostname' fields
 */
export class PostBunyanTransform extends Transform {
  private raw: boolean
  /**
   * Constructs a new transform.
   * Options:
   *  - {boolean} raw: if true, returns raw JavaScript record object instead of JSON
   */
  constructor(options?: any) {
    options = options || {}
    options.objectMode = true
    super(options)
    this.raw = options.raw || false
  }

  public _transform(obj, endcoding, cb) {
    const toremove = ['v', 'pid', 'hostname']
    let removed = _.omit(obj, toremove)
    if (this.raw) {
      cb(null, removed)
    } else {
      cb(null, JSON.stringify(removed))
    }
  }
}

/**
 * Takes a bunyan Stream object, and inserts a PostBunyanTransform
 * before the stream destination. Destination streams should be unaffected
 * except as the Transform molds objects passed through.
 * @param {object} bunyanStream following bunyan 'Stream' semantics
 *   bunyanStream.stream must be defined
 * @return {bunyan Stream} the bunyan Stream with the Transform applied
 */
export function applyPostBunyanTransform(bunyanStream: bunyan.Stream) {
  let transform = new PostBunyanTransform({
    raw: bunyanStream.type === 'raw'
  })
  transform.pipe(bunyanStream.stream as NodeJS.WritableStream)
  let newStream = _.clone(bunyanStream)
  newStream.stream = transform
  return newStream
}
