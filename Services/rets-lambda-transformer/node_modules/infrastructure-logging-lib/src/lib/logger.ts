import * as BLogger from 'bunyan'
import * as os from 'os'
const uuid: any = require('uuid')
import * as _ from 'lodash'
import { handleErrorsOnPublicMethods, getKinesisLogStream, EstablishKinesisStreamOptions } from './core'
import { EstablishLogEntriesStreamOptions, getLogEntriesBunyanStream } from './logentries'
import { applyPostBunyanTransform } from './transforms'
import DebugStream from './debug'

export interface ILogger {
  audit(msg: string, level: AUDITLEVELS, context?: any): void;
  boundary(edge: string, context?: any): void;
  error(err: Error, context?: any): void;
  telemetry(name: string, targetType: string, unit: string, value: any, context?: any): void;
  addStream(stream: BLogger.Stream): void;
  setAutoContext(useAutoContext: boolean): void;
  getName(): any;
  mergeContext(context: any): void;
  setContext(context?: any): void;
}

export interface ILoggerImplementationOptions {
  kinesis?: EstablishKinesisStreamOptions
  logentries?: EstablishLogEntriesStreamOptions
  streams?: BLogger.Stream[]
  serializers?: BLogger.Serializers
}

// const ERROR_LEVELS = ['error', 'fatal']
const AUDIT_LEVELS = ['trace', 'debug', 'info', 'warn']
export type AUDITLEVELS = 'trace' | 'debug' | 'info' | 'warn'

/**
 * Custom Logger class with special log methods
 * Options available:
 *  - {string} name (required): the name of the Logger
 *  - {Object} context (optional): context attributes shared across all messages.
 *  - {boolean} autoContext (optional): if true, adds in generated context
 *      attributes based on system information.
 *  - {Array} streams (optional): bunyan style streams to be added to this Logger
 */
export class Logger implements ILogger {

  public static enablePostBunyanTransform: boolean

  private context: any
  private useAutoContext: boolean
  private autoContext: any
  private bunyanLogger: BLogger

  /**
   * Generates the bunyan name of the logger based on appName_serviceName
   * @return {string}
   */
  public static getLoggerName(appName: string, serviceName: string) {
    return `${appName}_${serviceName}`
  }

  /**
       * Generates the automatic context for a given logger.
       * @return {object} The generated context
       */
  private static _getAutoContext() {
    return {
      'os': {
        'architecture': os.arch(),
        'hostname': os.hostname(),
        'platform': os.platform(),
        'release': os.release()
      }
    }
  }

  constructor(
    public appName: string,
    public serviceName: string,
    context?: any,
    implementation?: ILoggerImplementationOptions) {
    this.context = context || {}
    this.useAutoContext = false
    this.autoContext = Logger._getAutoContext()
    this.bunyanLogger = createBunyanLogger(Logger.getLoggerName(appName, serviceName), implementation)
  }

  /**
   * Sends an audit message.
   * Allows for level to be specified as one of:
   *  - 'trace', 'debug', 'info' (default), 'warn'
   * @param {string} msg - log message
   * @param {enum} level - the log level to be used
   * @param {object} context - extra context associated with the individual log event
   */
  public audit(msg: string, level: AUDITLEVELS, context?: any) {
    level = AUDIT_LEVELS.indexOf(level) > -1 ? level : 'info'
    let enhancements = {
      'context': context || {},
      'eventType': 'audit'
    }
    enhancements = this._addCommonEnhancements(enhancements)
    this.bunyanLogger[level](enhancements, msg)
  }

  /**
   * Sends a boundary message.
   * @param {string} edge - indicates if this is the 'start' or 'end' of an event
   * @param {object} context - extra context associated with the individual log event
   */
  public boundary(edge: string, context?: any) {
    let enhancements = {
      'boundary': {
        'edge': edge
      },
      'context': context || {},
      'eventType': 'boundary'
    }
    enhancements = this._addCommonEnhancements(enhancements)
    this.bunyanLogger.info(enhancements, '')
  }

  /**
   * Sends an error event
   * @param {object} err - the error object
   * @param {object} context - extra context associated with the individual log event
   */
  public error(err: Error, context?: any) {
    let enhancements = {
      'err': err,
      'context': context || {},
      'eventType': 'error'
    }
    enhancements = this._addCommonEnhancements(enhancements)
    this.bunyanLogger.error(enhancements)
  }

  /**
   * Sends a telemetry event that measures something about the code execution
   * @param {string} name - name of the aspect being measured
   * @param {enum} targetType - type of metric being targeted
   * @param {string} unit - the unit associated with the value
   * @param {any} value - value associate with this event
   * @param {object} context - extra context associated with the individual log event
   */
  public telemetry(name: string, targetType: string, unit: string, value: any, context?: any) {
    let enhancements = {
      'telemetry': {
        'name': name,
        'targetType': targetType,
        'unit': unit,
        'value': value
      },
      'context': context || {},
      'eventType': 'telemetry'
    }
    enhancements = this._addCommonEnhancements(enhancements)
    this.bunyanLogger.info(enhancements)
  }

  /**
   * Adds a bunyan style stream to send all log messages to
   * @param {bunyan Stream} stream The bunyan style stream to be added
   */
  public addStream(stream: BLogger.Stream) {
    // this.bunyanLogger.addStream(applyPostBunyanTransform(stream))
    this.bunyanLogger.addStream(stream)
  }

  /**
   * Enable or disable automatic host context gathering.
   * @param {boolean} autoContext - true to enable, false to disable
   */
  public setAutoContext(useAutoContext: boolean) {
    this.useAutoContext = useAutoContext
  }

  /**
   * Gets the name of this logger
   */
  public getName() {
    return this.bunyanLogger.fields.name
  }

  /**
   * Merge or append context information to Subsequent Logger calls
   * { context: {} } object
   */
  public mergeContext(context: any) {
    this.context = _.merge(this.context, context)
  }

  /**
   * Reset context information to Subsequent Logger calls
   * { context: {} } object
   */
  public setContext(context?: any) {
    this.context = context
  }

  /**
   * Adds enhancement data common to all event messages
   * @param {object} baseEnh - extra data associated with this specific event/type
   * @param {object} The result of the common enhancements merged with the base
   * enhancements
   */
  private _addCommonEnhancements(baseEnh) {
    // Source objects are applied from left to right.
    // Once a property is set, additional values of the same property are ignored.
    let sharedContext: any = this.useAutoContext
      ? _.defaultsDeep({}, this.context, this.autoContext)
      : _.defaultsDeep({}, this.context)
    if (!sharedContext.correlationID) {
      sharedContext.correlationID = uuid.v1()
    }
    let defaultEnh = {
      type: this.appName,
      service: this.serviceName,
      context: sharedContext
    }
    let overEnh = {
      eventID: uuid.v1()
    }
    // Subsequent sources overwrite property assignments of previous sources.
    return _.merge(defaultEnh, baseEnh, overEnh)
  }
}
handleErrorsOnPublicMethods(Logger)

/**
 * Creates a bunyan Logger object with automatic kinesis stream and error
 * serializer.
 * @param {string} name The name to give the new bunyan Logger
 * @return {bunyan.Logger} The new bunyan Logger
 */
export function createBunyanLogger(name, options?: ILoggerImplementationOptions) {
  let streams: BLogger.Stream[] = []
  if (process.env.DEBUG && String.prototype.includes.call(process.env.DEBUG, 'logginglib')) {
    streams.push({
      level: 'trace',
      stream: new DebugStream()
    })
  }
  let serializers = { err: BLogger.stdSerializers['err'] } as BLogger.Serializers
  if (_.isObjectLike(options)) {
    if (_.isObjectLike(options.kinesis)) {
      streams.push(getKinesisBunyanStream(options.kinesis))
    }
    if (_.isObjectLike(options.logentries)) {
      streams.push(getLogEntriesBunyanStream(options.logentries))
    }
    if (_.isArray(options.streams)) {
      streams = streams.concat(options.streams)
    }
    if (_.isObjectLike(options.serializers)) {
      serializers = options.serializers
    }
  }
  return BLogger.createLogger({ name, serializers, streams })
}

function getKinesisBunyanStream(options: EstablishKinesisStreamOptions): BLogger.Stream {
  let stream: BLogger.Stream = {
    level: options.level || 'info',
    stream: getKinesisLogStream(options),
    type: 'raw'
  }
  let kinesisBunyanStream = Logger.enablePostBunyanTransform
    ? applyPostBunyanTransform(stream)
    : stream
  return kinesisBunyanStream
}
