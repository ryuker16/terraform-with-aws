import * as Promise from 'bluebird'
const kinesis: any = Promise.promisifyAll(require('kinesis'))
import { PassThrough } from 'stream'
import { KinesifyTransform } from './transforms'
import * as _ from 'lodash'

export type LogLevels = 'trace' | 'debug' | 'info' | 'warn' | 'error'

/**
 * options include:

region: a string, or (deprecated) object with AWS credentials, host, port, etc (resolved from env or file by default)
credentials: an object with accessKeyId/secretAccessKey properties (resolved from env, file or IAM by default)
shards: an array of shard IDs, or shard objects. If not provided, these will be fetched and cached.
oldest: if truthy, then will start at the oldest records (using TRIM_HORIZON) instead of the latest
writeConcurrency: how many parallel writes to allow (1 by default)
cacheSize: number of PartitionKey-to-SequenceNumber mappings to cache (1000 by default)
agent: HTTP agent used (uses Node.js defaults otherwise)
timeout: HTTP request timeout (uses Node.js defaults otherwise)
initialRetryMs: first pause before retrying under the default policy (50 by default)
maxRetries: max number of retries under the default policy (10 by default)
errorCodes: array of Node.js error codes to retry on (['EADDRINFO', 'ETIMEDOUT', 'ECONNRESET', 'ESOCKETTIMEDOUT', 'ENOTFOUND', 'EMFILE'] by default)
errorNames: array of Kinesis exceptions to retry on (['ProvisionedThroughputExceededException', 'ThrottlingException'] by default)
retryPolicy: a function to implement a retry policy different from the default one
 */
export interface KinesisStreamOptions {
  region?: string
  credentials?: {
    accessKeyId?: string
    secretAccessKey?: string
  },
  shards?: string[],
  oldest?: boolean,
  writeConcurrency?: number
  cacheSize?: number
  timeout?: number
  maxRetries?: number
  errorCodes?: ErrorCodes[]
}
export interface EstablishKinesisStreamOptions {
  level?: LogLevels
  connection: KinesisStreamOptions,
  stream: {
    name: string,
    shards: number
  }
  PartitionKey: string
}
export type ErrorCodes = 'EADDRINFO' | 'ETIMEDOUT' | 'ECONNRESET' | 'ESOCKETTIMEDOUT' | 'ENOTFOUND' | 'EMFILE'
export type RetryCodes = 'ProvisionedThroughputExceededException' | 'ThrottlingException'

// Set up the shared kinesisLogStream
export function getKinesisLogStream(options: EstablishKinesisStreamOptions) {
  if (!_.isObjectLike(options)) {
    throw new TypeError('EstablishKinesisStreamOptions')
  }

  let kt = new KinesifyTransform({ PartitionKey: options.PartitionKey })

  /* istanbul ignore else */
  if (process.env.NODE_ENV === 'test') {
    let testKinesisPassThrough = new PassThrough({ objectMode: true })
    kt.pipe(testKinesisPassThrough)
  } else {
    let kinesisRawStream = establishKinesisStream(options)
    kt.pipe(kinesisRawStream)
  }

  return kt
}

/**
 * Creates a stream that recieves JSON object messages and streams and sends
 * them to Kinesis. Ensures that the Kinesis stream has been created.
 * @param {object} cfg - Configuration object for the kinesis stream.
 *   Must have cfg.stream.name, cfg.stream.sharts, cfg.connection defined.
 */
function establishKinesisStream(cfg: EstablishKinesisStreamOptions): NodeJS.WritableStream {
  let streamConnection = _.assign({ name: cfg.stream.name }, cfg.connection)
  // Note: kinesis.stream is NOT asynchronous
  return kinesis.stream(streamConnection)
}

/**
 * Wraps a function decorator so wrappers produced by the decorator have the
 * same properties as the original function.
 * @param {function} decorator - a function that accepts a method and returns a
 * wrapped method.
 */
function fixDecorator(decorator) {
  return function (f) {
    let wrapper = decorator(f)
    let properties = Object.getOwnPropertyNames(f)
    for (let i = 0; i < properties.length; i++) {
      let prop = properties[i]
      if (f.hasOwnProperty(prop)) {
        Object.defineProperty(wrapper, prop, Object.getOwnPropertyDescriptor(f, prop))
      }
    }
    return wrapper
  }
}

/**
 * Decorates f to handle uncaught Errors. Returned function behaves like f when
 * there no errors. When an Error is caught, returns the result of handler
 * called on the error. Based off Python decorator conventions.
 * @param {function} f - function to be decorated
 * @param {function} handler (optional) - called on any caught error.
 */
export function handleErrors(f: Function, handler?: Function) {
  handler = handler || function () { }
  function decorator(fn) {
    let wrapper = function () {
      try {
        return fn.apply(this, arguments)
      } catch (err) {
        return handler(err)
      }
    }
    return wrapper
  }
  return fixDecorator(decorator)(f)
}

/**
 * Applies error handling decorator to all the given methods on the class's prototype.
 * @param {class} klass - the class whose methods will be decorated
 * @param {Array[string]} methods - the method names to be wrapped
 * @param {function} handler - function to be called on caught errors
 */
export function handleErrorsOnMethods(klass: any, methods: string[], handler?: Function) {
  for (let i = 0; i < methods.length; i++) {
    klass.prototype[methods[i]] = handleErrors(klass.prototype[methods[i]], handler)
  }
}

/**
 * Applies error handling decorator to all public (no leading '_') methods on a
 * class
 * @param {class} klass - the class whose methods will be decorated
 * @param {function} handler - function to be called on caught errors
 */
export function handleErrorsOnPublicMethods(klass: any, handler?: Function) {
  let pNames = Object.getOwnPropertyNames(klass.prototype)
  let pubMethods = pNames.filter(function (pName) {
    return klass.prototype[pName] instanceof Function && pName[0] !== '_'
  })
  handleErrorsOnMethods(klass, pubMethods, handler)
}
