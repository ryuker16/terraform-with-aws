/* eslint-env node, mocha */
'use strict'
var chai = require('chai')
var expect = chai.expect
var core = require('../../dist/lib/core')
var handleErrors = core.handleErrors
var handleErrorsOnMethods = core.handleErrorsOnMethods
var handleErrorsOnPublicMethods = core.handleErrorsOnPublicMethods
var getKinesisLogStream = core.getKinesisLogStream

describe('handleErrors()', function () {
  describe('function', function () {
    it('maintans non-error functionality', function () {
      let fn = function () { return 'something' }
      expect(handleErrors(fn)()).to.equal('something')
    })
    it('catches errors', function () {
      let errFn = function () { throw new Error() }
      expect(errFn).to.throw(Error)
      expect(handleErrors(errFn)).to.not.throw(Error)
    })
    it('maintains function name', function () {
      function namedFn () { }
      expect(handleErrors(namedFn)).to.have.property('name').equal('namedFn')
    })
    it('calls handler on error', function () {
      let errFn = function () { throw new Error('message') }
      let handler = function (err) { return err.message }
      expect(handleErrors(errFn, handler)()).to.equal('message')
    })
  })

  describe('method', function () {
    function handler (err) { return err.message }

    class MyClass {
      constructor (name) {
        this.name = name
      }

      errMethod () { throw new Error('message') }
      setName (name) { this.name = name }
      getName () { return this.name }
    }
    MyClass.prototype.wrappedErrMethod = handleErrors(MyClass.prototype.errMethod, handler)
    MyClass.prototype.wrappedSetName = handleErrors(MyClass.prototype.setName, handler)
    MyClass.prototype.wrappedGetName = handleErrors(MyClass.prototype.getName, handler)

    let joe = new MyClass('Joe')
    let tim = new MyClass('Tim')

    it('maintans non-error functionality', function () {
      expect(joe.wrappedGetName()).to.equal('Joe')
      expect(tim.wrappedGetName()).to.equal('Tim')
      joe.wrappedSetName('Joseph')
      expect(joe.wrappedGetName()).to.equal('Joseph')
      expect(tim.wrappedGetName()).to.equal('Tim')
    })
    it('catches errors', function () {
      expect(joe.wrappedErrMethod).to.not.throw(Error)
    })
    it('maintains function name', function () {
      expect(joe.wrappedErrMethod).to.have.property('name').equal('errMethod')
    })
    it('calls handler on error', function () {
      expect(joe.wrappedErrMethod()).to.equal('message')
    })
  })
})

describe('handleErrorsOnMethods', function () {
  function handler (err) { return err.message }

  class MyClass {
    errMethod () { throw new Error('message') }
    goodMethod () { return 'I work!' }
  }
  handleErrorsOnMethods(MyClass, ['errMethod', 'goodMethod'], handler)

  let myObj = new MyClass()

  it('catches errors', function () {
    expect(myObj.errMethod).to.not.throw(Error)
  })
  it('applies handler on errors', function () {
    expect(myObj.errMethod()).to.equal('message')
  })
  it('maintains non-error functionality', function () {
    expect(myObj.goodMethod()).to.equal('I work!')
  })
})

describe('handleErrorsOnPublicMethods', function () {
  function handler (err) { return err.message }

  class MyClass {
    errMethod () { throw new Error('message') }
    goodMethod () { return 'I work!' }
  }
  handleErrorsOnPublicMethods(MyClass, handler)

  let myObj = new MyClass()

  it('catches errors', function () {
    expect(myObj.errMethod).to.not.throw(Error)
  })
  it('applies handler on errors', function () {
    expect(myObj.errMethod()).to.equal('message')
  })
  it('maintains non-error functionality', function () {
    expect(myObj.goodMethod()).to.equal('I work!')
  })
})
describe('getKinesisLogStream', function () {
  it('should TypeError when EstablishKinesisStreamOptions is not set', function () {
    expect(function () {
      getKinesisLogStream(null)
    }).to.throw(TypeError)
    expect(function () {
      getKinesisLogStream(undefined)
    }).to.throw(TypeError)
    expect(function () {
      getKinesisLogStream()
    }).to.throw(TypeError)
  })
})
