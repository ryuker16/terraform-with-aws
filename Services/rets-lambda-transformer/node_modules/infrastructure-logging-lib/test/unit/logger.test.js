/* eslint-env node, mocha */
'use strict'
var chai = require('chai')
var expect = chai.expect
var sinon = require('sinon')
chai.use(require('sinon-chai'))
var PassThrough = require('stream').PassThrough
var Faker = require('faker')
var bunyan = require('bunyan')
var _ = require('lodash')
var _logger = require('../../dist/lib/logger')
var transforms = require('../../dist/lib/transforms')
var DebugStream = require('../../dist/lib/debug').default
var getConsoleStream = require('../../dist/lib/consoleStream').getConsoleStream
var Logger = _logger.Logger
var createBunyanLogger = _logger.createBunyanLogger
var applyPostBunyanTransform = transforms.applyPostBunyanTransform
var appName = 'testAppName'
var serviceName = 'testServiceName'

describe('Logger', function () {
  let logger
  let stream

  beforeEach(function () {
    stream = new PassThrough({ objectMode: true })
    logger = new Logger(appName, serviceName, { 'customContext': true })
    logger.addStream({
      name: 'testStream',
      stream: stream,
      type: 'raw'
    })
  })

  afterEach(function () {
    // unpipe kinesis stream to avoid event listners building up
    let loggerStreams = logger.bunyanLogger.streams
    for (let i = 0; i < loggerStreams.length; i++) {
      if (loggerStreams[i].name === 'kinesis') {
        loggerStreams[i].stream.unpipe()
      }
    }
  })

  /**
   * Checks that the last log entry has all basic keys
   */
  const expectHasBasicProps = function (logObj) {
    let baseKeys = ['name', 'level', 'time', 'type', 'msg', 'eventID',
      'context', 'eventType', 'service']
    expect(logObj).to.contain.all.keys(baseKeys)
    expect(logObj).to.have.deep.property('type', appName)
    expect(logObj).to.have.deep.property('service', serviceName)
    expect(logObj).to.have.property('context').with.property('correlationID')
    expect(logObj).to.have.property('context').with.property('customContext')
  }

  describe('boundary(edge, context)', function () {
    it('has basic properties', function () {
      logger.boundary('start', { name: 'test' })
      expectHasBasicProps(stream.read())
    })
    it('has boundary properties', function () {
      logger.boundary('start', { name: 'test' })
      expect(stream.read()).to.have.property('boundary')
        .contain.all.keys('edge')
    })
    it('defaults context to the constructor context', function () {
      logger.boundary('start')
      expectHasBasicProps(stream.read())
    })
  })

  describe('audit()', function () {
    it('has basic properties', function () {
      logger.audit('test')
      expectHasBasicProps(stream.read())
    })
    it('defaults to level to info', function () {
      logger.audit('test', 'notalevel')
      let logObj = stream.read()
      expectHasBasicProps(logObj)
      expect(logObj).to.have.property('level').and.be.eq(30)
    })
    it('logs warn when set as level', function () {
      logger.audit('test', 'warn')
      let logObj = stream.read()
      expectHasBasicProps(logObj)
      expect(logObj).to.have.property('level').and.be.eq(40)
    })
  })

  describe('error()', function () {
    it('has basic properties', function () {
      logger.error(new Error())
      expectHasBasicProps(stream.read())
    })
    it('has error properties', function () {
      logger.error(new Error())
      expect(stream.read()).to.have.property('err')
        .contain.all.keys('message', 'name', 'signal', 'stack', 'code')
    })
  })

  describe('telemetry()', function () {
    it('has basic properties', function () {
      logger.telemetry('testMetric', 'counter', 'testItem', 1)
      expectHasBasicProps(stream.read())
    })
    it('has telemetry properties', function () {
      logger.telemetry('testMetric', 'counter', 'testItem', 1)
      expect(stream.read()).to.have.property('telemetry')
        .contain.all.keys('name', 'targetType', 'unit', 'value')
    })
  })

  describe('_addCommonEnhancements()', function () {
    it('has basic properties', function () {
      let res = logger._addCommonEnhancements({})
      expect(res).to.have.all.keys('eventID', 'context', 'type', 'service')
      expect(res).to.have.property('type', appName)
      expect(res).to.have.property('service', serviceName)
      expect(res).to.have.property('context').with.property('correlationID')
    })
    it('overrides eventID', function () {
      let startID = 'override me'
      let res = logger._addCommonEnhancements({ eventID: startID })
      expect(res).to.have.property('eventID').not.equal(startID)
    })
    it('correlationID is overridden', function () {
      let startID = 'new id'
      let res = logger._addCommonEnhancements({ context: { correlationID: startID } })
      expect(res.context.correlationID).to.equal(startID)
    })
    it('merges the autoContext with setAutoContext(true)', function () {
      let startID = 'new id'
      logger.setAutoContext(true)
      let otherContextProp = Faker.random.uuid()
      logger.setContext({ otherContextProp })
      let res = logger._addCommonEnhancements({ context: { correlationID: startID } })
      expect(res.context.os, 'context includes autoContext with { os }').to.be.deep.eq(Logger._getAutoContext().os)
    })
  })

  describe('_getAutoContext()', function () {
    it('has basic properties', function () {
      let res = Logger._getAutoContext()
      let expectedKeys = ['architecture', 'hostname', 'platform', 'release']
      expect(res).to.have.property('os').with.all.keys(expectedKeys)
    })
  })

  describe('setAutoContext(boolean)', function () {
    it('should set useAutoContext', function () {
      logger.setAutoContext(true)
      expect(logger.useAutoContext).to.be.eq(true)
      logger.setAutoContext(false)
      expect(logger.useAutoContext).to.be.eq(false)
    })
  })

  describe('setContext(context)', function () {
    it('should set this.context', function () {
      let context = { foo: 'bar' }
      logger.setContext(context)
      expect(logger.context).to.be.eq(context)
    })
  })

  describe('mergeContext()', function () {
    it('adds a property to the initial context', function () {
      let logger = new Logger('testDomain', 'test', { 'foo': 'bar' })
      logger.mergeContext({ 'foo1': 'bar' })
      let res = logger._addCommonEnhancements()
      expect(res.context).to.have.any.keys(['foo', 'foo1'])
    })
    it('overwrites a property of the initial context', function () {
      let logger = new Logger('testDomain', 'test', { 'foo': 'bar' })
      logger.mergeContext({ 'foo': 'abc' })
      let res = logger._addCommonEnhancements()
      expect(res.context).to.have.property('foo').and.equal('abc')
    })
    it('add a property of the initial context when empty', function () {
      let logger = new Logger('testDomain', 'test')
      logger.mergeContext({ 'foo': 'abc' })
      let res = logger._addCommonEnhancements()
      expect(res.context).to.have.property('foo').and.equal('abc')
    })
    it('overwrite a deep property of the initial context when empty', function () {
      let logger = new Logger('testDomain', 'test', { 'deep': { 'foo': 'bar' } })
      logger.mergeContext({ 'deep': { 'foo': 'abc' } })
      let res = logger._addCommonEnhancements()
      expect(res.context.deep).to.have.property('foo').and.equal('abc')
    })
    it('not overwrite a deep property of the initial context when supplied in enhancements', function () {
      let logger = new Logger('testDomain', 'test', { 'deep': { 'foo': 'bar' } })
      logger.mergeContext({ 'deep': { 'foo': 'abc', 'foo1': true } })
      logger.mergeContext({ 'deep': { 'foo1': false } })
      let res = logger._addCommonEnhancements({ context: { 'deep': { 'foo': 'xyz' } } })
      expect(res.context.deep).to.have.property('foo').and.equal('xyz')
      expect(res.context.deep).to.have.property('foo1').and.equal(false)
    })
  })

  describe('applyPostBunyanTransform', function () {
    let bunyanPassThrough
    let passThrough
    let rawPassThrough
    let bunyanRawPassThrough

    beforeEach(function () {
      passThrough = new PassThrough()
      bunyanPassThrough = {
        name: 'passThrough',
        stream: passThrough
      }
      rawPassThrough = new PassThrough({ objectMode: true })
      bunyanRawPassThrough = {
        name: 'rawPassThrough',
        stream: rawPassThrough,
        type: 'raw'
      }
    })

    it('passes objects through on raw stream', function () {
      let postPassThrough = applyPostBunyanTransform(bunyanRawPassThrough)
      postPassThrough.stream.write({ a: 1 })
      expect(rawPassThrough.read()).to.be.deep.equal({ a: 1 })
    })
    it('passes JSON through on non-raw stream', function () {
      let postPassThrough = applyPostBunyanTransform(bunyanPassThrough)
      postPassThrough.stream.write({ a: 1 })
      let out = passThrough.read()
      expect(out).to.satisfy(function (o) {
        return typeof o === 'string' || o instanceof Buffer
      })
      expect(JSON.parse(out)).to.be.deep.equal({ a: 1 })
    })
  })
  describe('with addStream of ConsoleStream', function () {
    it('should write log objects to the console with all basic properties', function () {
      let consoleStream = getConsoleStream()
      let consoleLogSpy = sinon.spy(consoleStream.stream, 'consolelog')
      logger.addStream(consoleStream)
      logger.audit('msg', 'info', { foo: 'bar' })
      expect(consoleLogSpy).to.have.been.called
      expectHasBasicProps(JSON.parse(consoleLogSpy.getCall(0).args[0]))
    })
    it('should NOT write log objects to the console with a min level below low entry', function () {
      let consoleStream = getConsoleStream({ level: 'warn' })
      let consoleLogSpy = sinon.spy(consoleStream.stream, 'consolelog')
      logger.addStream(consoleStream)
      logger.audit('msg', 'info', { foo: 'bar' })
      expect(consoleLogSpy).not.to.have.been.called
    })
  })
})

describe('createBunyanLogger', function () {
  let sandbox = null
  let createLoggerStub = null
  let name = null
  beforeEach(function () {
    sandbox = sinon.sandbox.create()
    createLoggerStub = sandbox.stub(bunyan, 'createLogger').returns({})
    name = Faker.name.firstName()
  })
  afterEach(function () {
    sandbox.restore()
  })

  var getBunyanArgs = function () {
    return createLoggerStub.getCall(0).args[0]
  }
  var getBunyanStreams = function () {
    return getBunyanArgs().streams
  }
  describe('when process.env.DEBUG', function () {
    before(function () {
      process.env.DEBUG = 'logginglib'
    })
    after(function () {
      process.env.DEBUG = ''
    })
    it('should read process.env.DEBUG and create a DebugStream', function () {
      createBunyanLogger(name, {})
      expect(createLoggerStub.getCall(0).args[0].streams[0].stream).to.be.instanceOf(DebugStream)
    })
  })

  describe('with options { kinesis }', function () {
    it('should pass bunyan { streams[].stream } a KinesifyTransform', function () {
      let options = { kinesis: { PartitionKey: Faker.random.uuid() } }
      expect(_.isObjectLike(options), 'options').to.be.ok
      expect(_.isObject(options.kinesis), 'options.kinesis').to.be.ok
      createBunyanLogger(name, options)
      expect(getBunyanStreams()).to.have.lengthOf(1)
      expect(getBunyanStreams()[0].stream)
        .to.have.a.property('write')
        .and.be.a('function')
    })
    it('should pass bunyan { streams[].stream } a KinesifyTransform', function () {
      let options = { kinesis: { PartitionKey: Faker.random.uuid(), level: Faker.lorem.word() } }
      createBunyanLogger(name, options)
      expect(getBunyanStreams()[0].level).to.be.eq(options.kinesis.level)
      expect(getBunyanStreams()[0].stream).to.be.instanceOf(require('stream').Transform)
    })
  })
  describe('with options { logentries }', function () {
    it('should pass bunyan { streams[].stream } a logentries Writable', function () {
      createBunyanLogger(name, { logentries: { token: Faker.random.uuid() } })
      expect(getBunyanStreams()[0].stream).to.be.an.instanceOf(require('stream').Writable)
      expect(getBunyanStreams()).to.have.lengthOf(1)
    })
  })
  describe('with options { streams: [] }', function () {
    it('should pass bunyan the list of supplied streams', function () {
      createBunyanLogger(name, { streams: [{ level: 'info', stream: new DebugStream() }] })
      expect(getBunyanStreams()[0].stream).to.be.an.instanceOf(DebugStream)
      expect(getBunyanStreams()).to.have.lengthOf(1)
    })
  })
  describe('with options { serializers: [] }', function () {
    it('should pass bunyan the list of supplied streams', function () {
      let options = { serializers: [] }
      createBunyanLogger(name, options)
      expect(getBunyanArgs().serializers).to.be.eq(options.serializers)
    })
  })
})
