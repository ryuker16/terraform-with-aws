/// <reference types="bunyan" />
import * as BLogger from 'bunyan';
import { EstablishKinesisStreamOptions } from './core';
import { EstablishLogEntriesStreamOptions } from './logentries';
export interface ILogger {
    audit(msg: string, level: AUDITLEVELS, context?: any): void;
    boundary(edge: string, context?: any): void;
    error(err: Error, context?: any): void;
    telemetry(name: string, targetType: string, unit: string, value: any, context?: any): void;
    addStream(stream: BLogger.Stream): void;
    setAutoContext(useAutoContext: boolean): void;
    getName(): any;
    mergeContext(context: any): void;
    setContext(context?: any): void;
}
export interface ILoggerImplementationOptions {
    kinesis?: EstablishKinesisStreamOptions;
    logentries?: EstablishLogEntriesStreamOptions;
    streams?: BLogger.Stream[];
    serializers?: BLogger.Serializers;
}
export declare type AUDITLEVELS = 'trace' | 'debug' | 'info' | 'warn';
/**
 * Custom Logger class with special log methods
 * Options available:
 *  - {string} name (required): the name of the Logger
 *  - {Object} context (optional): context attributes shared across all messages.
 *  - {boolean} autoContext (optional): if true, adds in generated context
 *      attributes based on system information.
 *  - {Array} streams (optional): bunyan style streams to be added to this Logger
 */
export declare class Logger implements ILogger {
    appName: string;
    serviceName: string;
    static enablePostBunyanTransform: boolean;
    private context;
    private useAutoContext;
    private autoContext;
    private bunyanLogger;
    /**
     * Generates the bunyan name of the logger based on appName_serviceName
     * @return {string}
     */
    static getLoggerName(appName: string, serviceName: string): string;
    /**
         * Generates the automatic context for a given logger.
         * @return {object} The generated context
         */
    private static _getAutoContext();
    constructor(appName: string, serviceName: string, context?: any, implementation?: ILoggerImplementationOptions);
    /**
     * Sends an audit message.
     * Allows for level to be specified as one of:
     *  - 'trace', 'debug', 'info' (default), 'warn'
     * @param {string} msg - log message
     * @param {enum} level - the log level to be used
     * @param {object} context - extra context associated with the individual log event
     */
    audit(msg: string, level: AUDITLEVELS, context?: any): void;
    /**
     * Sends a boundary message.
     * @param {string} edge - indicates if this is the 'start' or 'end' of an event
     * @param {object} context - extra context associated with the individual log event
     */
    boundary(edge: string, context?: any): void;
    /**
     * Sends an error event
     * @param {object} err - the error object
     * @param {object} context - extra context associated with the individual log event
     */
    error(err: Error, context?: any): void;
    /**
     * Sends a telemetry event that measures something about the code execution
     * @param {string} name - name of the aspect being measured
     * @param {enum} targetType - type of metric being targeted
     * @param {string} unit - the unit associated with the value
     * @param {any} value - value associate with this event
     * @param {object} context - extra context associated with the individual log event
     */
    telemetry(name: string, targetType: string, unit: string, value: any, context?: any): void;
    /**
     * Adds a bunyan style stream to send all log messages to
     * @param {bunyan Stream} stream The bunyan style stream to be added
     */
    addStream(stream: BLogger.Stream): void;
    /**
     * Enable or disable automatic host context gathering.
     * @param {boolean} autoContext - true to enable, false to disable
     */
    setAutoContext(useAutoContext: boolean): void;
    /**
     * Gets the name of this logger
     */
    getName(): any;
    /**
     * Merge or append context information to Subsequent Logger calls
     * { context: {} } object
     */
    mergeContext(context: any): void;
    /**
     * Reset context information to Subsequent Logger calls
     * { context: {} } object
     */
    setContext(context?: any): void;
    /**
     * Adds enhancement data common to all event messages
     * @param {object} baseEnh - extra data associated with this specific event/type
     * @param {object} The result of the common enhancements merged with the base
     * enhancements
     */
    private _addCommonEnhancements(baseEnh);
}
/**
 * Creates a bunyan Logger object with automatic kinesis stream and error
 * serializer.
 * @param {string} name The name to give the new bunyan Logger
 * @return {bunyan.Logger} The new bunyan Logger
 */
export declare function createBunyanLogger(name: any, options?: ILoggerImplementationOptions): BLogger;
