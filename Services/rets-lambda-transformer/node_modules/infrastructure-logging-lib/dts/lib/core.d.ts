import { KinesifyTransform } from './transforms';
export declare type LogLevels = 'trace' | 'debug' | 'info' | 'warn' | 'error';
/**
 * options include:

region: a string, or (deprecated) object with AWS credentials, host, port, etc (resolved from env or file by default)
credentials: an object with accessKeyId/secretAccessKey properties (resolved from env, file or IAM by default)
shards: an array of shard IDs, or shard objects. If not provided, these will be fetched and cached.
oldest: if truthy, then will start at the oldest records (using TRIM_HORIZON) instead of the latest
writeConcurrency: how many parallel writes to allow (1 by default)
cacheSize: number of PartitionKey-to-SequenceNumber mappings to cache (1000 by default)
agent: HTTP agent used (uses Node.js defaults otherwise)
timeout: HTTP request timeout (uses Node.js defaults otherwise)
initialRetryMs: first pause before retrying under the default policy (50 by default)
maxRetries: max number of retries under the default policy (10 by default)
errorCodes: array of Node.js error codes to retry on (['EADDRINFO', 'ETIMEDOUT', 'ECONNRESET', 'ESOCKETTIMEDOUT', 'ENOTFOUND', 'EMFILE'] by default)
errorNames: array of Kinesis exceptions to retry on (['ProvisionedThroughputExceededException', 'ThrottlingException'] by default)
retryPolicy: a function to implement a retry policy different from the default one
 */
export interface KinesisStreamOptions {
    region?: string;
    credentials?: {
        accessKeyId?: string;
        secretAccessKey?: string;
    };
    shards?: string[];
    oldest?: boolean;
    writeConcurrency?: number;
    cacheSize?: number;
    timeout?: number;
    maxRetries?: number;
    errorCodes?: ErrorCodes[];
}
export interface EstablishKinesisStreamOptions {
    level?: LogLevels;
    connection: KinesisStreamOptions;
    stream: {
        name: string;
        shards: number;
    };
    PartitionKey: string;
}
export declare type ErrorCodes = 'EADDRINFO' | 'ETIMEDOUT' | 'ECONNRESET' | 'ESOCKETTIMEDOUT' | 'ENOTFOUND' | 'EMFILE';
export declare type RetryCodes = 'ProvisionedThroughputExceededException' | 'ThrottlingException';
export declare function getKinesisLogStream(options: EstablishKinesisStreamOptions): KinesifyTransform;
/**
 * Decorates f to handle uncaught Errors. Returned function behaves like f when
 * there no errors. When an Error is caught, returns the result of handler
 * called on the error. Based off Python decorator conventions.
 * @param {function} f - function to be decorated
 * @param {function} handler (optional) - called on any caught error.
 */
export declare function handleErrors(f: Function, handler?: Function): any;
/**
 * Applies error handling decorator to all the given methods on the class's prototype.
 * @param {class} klass - the class whose methods will be decorated
 * @param {Array[string]} methods - the method names to be wrapped
 * @param {function} handler - function to be called on caught errors
 */
export declare function handleErrorsOnMethods(klass: any, methods: string[], handler?: Function): void;
/**
 * Applies error handling decorator to all public (no leading '_') methods on a
 * class
 * @param {class} klass - the class whose methods will be decorated
 * @param {function} handler - function to be called on caught errors
 */
export declare function handleErrorsOnPublicMethods(klass: any, handler?: Function): void;
