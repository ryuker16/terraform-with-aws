const Promise = require('bluebird')
const meld = require('meld')
export type AUDIT_LEVELS = "trace" | "debug" | 'info' | 'warn'
export interface ILogger {
  //Infrastructure-Logging-Lib
  boundary(edge: string, context?: any): void;
  telemetry(name: string, targetType: string, unit: string, value: any, context?: any): void;
  audit(msg: string, level: AUDIT_LEVELS, context?: any): void;
  error(err: Error, context?: any): void;
}
export interface IClassPrototype {
  constructor: { name: string }
}

interface IJoinPoint {
  args: any[]
  target: any
  proceed: (...args: any[]) => any
}

export interface IRemover {
  remove: () => void
}

export function wireMethod(
  obj: any,
  methodName: string,
  logger: ILogger): IRemover {
  return meld.around(obj, methodName, function (joinpoint: IJoinPoint) {
    let hrstart = process.hrtime();
    let edge = methodName
    try {
      logger.boundary(edge)
      let result = joinpoint.proceed()
      logger.boundary(edge, { exit: 0 })
      return result
    } catch (err) {
      logger.boundary(edge, { exit: 1 })
      logger.error(err)
      throw err
    } finally {
      let end = process.hrtime(hrstart)
      logger.telemetry(edge, 'executiontime', 'ms', (end[0] * 1000 + end[1] / 1000000))
    }
  })
}
export function wireMethodAsync(
  obj: any,
  methodName: string,
  logger: ILogger): IRemover {
  return meld.around(obj, methodName, function (joinpoint: IJoinPoint) {
    let hrstart = process.hrtime();
    let edge = methodName
    logger.boundary(edge)
    return Promise.resolve(joinpoint.proceed())
      .tap(function () {
        logger.boundary(edge, { exit: 0 })
      })
      .catch(function (err) {
        logger.boundary(edge, { exit: 1 })
        logger.error(err)
        throw err
      })
      .finally(function () {
        let end = process.hrtime(hrstart)
        logger.telemetry(edge, 'executiontime', 'ms', (end[0] * 1000 + end[1] / 1000000))
      })
  })
}
export function wirePrototypeMethod(
  classPrototype: IClassPrototype & Object,
  methodName: string,
  logger: ILogger): IRemover {
  return meld.around(classPrototype, methodName, function (joinpoint: IJoinPoint) {
    let hrstart = process.hrtime();
    let edge = `${classPrototype.constructor.name}.${methodName}`
    try {
      logger.boundary(edge)
      let result = joinpoint.proceed()
      logger.boundary(edge, { exit: 0 })
      return result
    } catch (err) {
      logger.boundary(edge, { exit: 1 })
      logger.error(err)
      throw err
    } finally {
      let end = process.hrtime(hrstart)
      logger.telemetry(edge, 'executiontime', 'ms', (end[0] * 1000 + end[1] / 1000000))
    }
  })
}
export function wirePrototypeMethodAsync(
  classPrototype: IClassPrototype & Object,
  methodName: string,
  logger: ILogger): IRemover {
  return meld.around(classPrototype, methodName, function (joinpoint: IJoinPoint) {
    let hrstart = process.hrtime();
    let edge = `${classPrototype.constructor.name}.${methodName}`
    logger.boundary(edge)
    return Promise.resolve(joinpoint.proceed())
      .tap(function () {
        logger.boundary(edge, { exit: 0 })
      })
      .catch(function (err) {
        logger.boundary(edge, { exit: 1 })
        logger.error(err)
        throw err
      })
      .finally(function () {
        let end = process.hrtime(hrstart)
        logger.telemetry(edge, 'executiontime', 'ms', (end[0] * 1000 + end[1] / 1000000))
      })
  })
}

function argumentNames(func) {
  var names = func.toString().match(/^[\s\(]*function[^(]*\(([^)]*)\)/)[1]
    .replace(/\/\/.*?[\r\n]|\/\*(?:.|[\r\n])*?\*\//g, '')
    .replace(/\s+/g, '').split(',')

  return names.length === 1 && !names[0] ? [] : names
}