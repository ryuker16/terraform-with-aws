'use strict'
const lib = require('../../lib')
const wirePrototypeMethod = lib.wirePrototypeMethod
const wirePrototypeMethodAsync = lib.wirePrototypeMethodAsync
const wireMethodAsync = lib.wireMethodAsync
const wireMethod = lib.wireMethod
const chai = require('chai')
const sinon = require('sinon')
const sinonChai = require('sinon-chai')
chai.use(sinonChai)
const expect = chai.expect
const Promise = require('bluebird')

class MyClass {
    methodDelay() {
        return Promise.delay(1000)
    }
    methodTrue() {
        return true
    }
    methodThrow() {
        throw new Error()
    }
}

describe('wirePrototypeMethod', function () {
    let logger = null
    let removers = []
    let instance = null
    beforeEach(function () {
        logger = sinon.stub({
            boundary: () => { },
            telemetry: () => { },
            error: () => { }
        })
        removers.push(wirePrototypeMethodAsync(MyClass.prototype, 'methodDelay', logger))
        removers.push(wirePrototypeMethod(MyClass.prototype, 'methodTrue', logger))
        removers.push(wirePrototypeMethod(MyClass.prototype, 'methodThrow', logger))
        instance = new MyClass()
    })
    afterEach(function () {
        removers.forEach(function (r) {
            r.remove()
        })
    })
    it('should wirePrototypeMethod methodDelay', function () {
        return instance.methodDelay()
            .then(function () {
                expect(logger.boundary).to.have.been.calledWith(sinon.match('MyClass.methodDelay'))
                expect(logger.telemetry).to.have.been.calledWith(sinon.match('MyClass.methodDelay'))
            })
    })
    it('should wirePrototypeMethod methodTrue', function () {
        let result = instance.methodTrue()
        expect(logger.boundary).to.have.been.calledWith(sinon.match('MyClass.methodTrue'))
        expect(logger.telemetry).to.have.been.calledWith(sinon.match('MyClass.methodTrue'))
        expect(result).to.be.equal(true)
    })
    it('should throw methodThrow', function () {
        try {
            instance.methodThrow()
        } catch (err) {
            expect(logger.boundary).to.have.been.calledWith(sinon.match('MyClass.methodThrow'), sinon.match.has('exit', 1))
            expect(logger.telemetry).to.have.been.calledWith(sinon.match('MyClass.methodThrow'))
            expect(logger.error).to.have.been.calledWith(err)
        }
    })
})

describe('wireMethodAsync', function () {
    let logger = null
    beforeEach(function () {
        logger = sinon.stub({
            boundary: () => { },
            telemetry: () => { },
            error: () => { }
        })
    })
    afterEach(function () {
    })
    it('should wireMethodAsync and return result', function () {
        let exp = { foo: 'bar' }
        let obj = {
            a: function () {
                return Promise.resolve(exp)
            }
        }
        wireMethodAsync(obj, 'a', logger)
        return obj.a().then(result => {
            expect(result).to.be.equal(exp)
            expect(logger.boundary).to.have.callCount(2)
        })
    })
    it('should wireMethod and return result', function () {
        let exp = { foo: 'bar' }
        let obj = {
            a: function () {
                return exp
            }
        }
        wireMethod(obj, 'a', logger)
        return Promise.resolve(obj.a()).then(result => {
            expect(result).to.be.equal(exp)
            expect(logger.boundary).to.have.callCount(2)
        })
    })
})
