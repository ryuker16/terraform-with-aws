"use strict";
var Promise = require('bluebird');
var meld = require('meld');
function wireMethod(obj, methodName, logger) {
    return meld.around(obj, methodName, function (joinpoint) {
        var hrstart = process.hrtime();
        var edge = methodName;
        try {
            logger.boundary(edge);
            var result = joinpoint.proceed();
            logger.boundary(edge, { exit: 0 });
            return result;
        }
        catch (err) {
            logger.boundary(edge, { exit: 1 });
            logger.error(err);
            throw err;
        }
        finally {
            var end = process.hrtime(hrstart);
            logger.telemetry(edge, 'executiontime', 'ms', (end[0] * 1000 + end[1] / 1000000));
        }
    });
}
exports.wireMethod = wireMethod;
function wireMethodAsync(obj, methodName, logger) {
    return meld.around(obj, methodName, function (joinpoint) {
        var hrstart = process.hrtime();
        var edge = methodName;
        logger.boundary(edge);
        return Promise.resolve(joinpoint.proceed())
            .tap(function () {
            logger.boundary(edge, { exit: 0 });
        })
            .catch(function (err) {
            logger.boundary(edge, { exit: 1 });
            logger.error(err);
            throw err;
        })
            .finally(function () {
            var end = process.hrtime(hrstart);
            logger.telemetry(edge, 'executiontime', 'ms', (end[0] * 1000 + end[1] / 1000000));
        });
    });
}
exports.wireMethodAsync = wireMethodAsync;
function wirePrototypeMethod(classPrototype, methodName, logger) {
    return meld.around(classPrototype, methodName, function (joinpoint) {
        var hrstart = process.hrtime();
        var edge = classPrototype.constructor.name + "." + methodName;
        try {
            logger.boundary(edge);
            var result = joinpoint.proceed();
            logger.boundary(edge, { exit: 0 });
            return result;
        }
        catch (err) {
            logger.boundary(edge, { exit: 1 });
            logger.error(err);
            throw err;
        }
        finally {
            var end = process.hrtime(hrstart);
            logger.telemetry(edge, 'executiontime', 'ms', (end[0] * 1000 + end[1] / 1000000));
        }
    });
}
exports.wirePrototypeMethod = wirePrototypeMethod;
function wirePrototypeMethodAsync(classPrototype, methodName, logger) {
    return meld.around(classPrototype, methodName, function (joinpoint) {
        var hrstart = process.hrtime();
        var edge = classPrototype.constructor.name + "." + methodName;
        logger.boundary(edge);
        return Promise.resolve(joinpoint.proceed())
            .tap(function () {
            logger.boundary(edge, { exit: 0 });
        })
            .catch(function (err) {
            logger.boundary(edge, { exit: 1 });
            logger.error(err);
            throw err;
        })
            .finally(function () {
            var end = process.hrtime(hrstart);
            logger.telemetry(edge, 'executiontime', 'ms', (end[0] * 1000 + end[1] / 1000000));
        });
    });
}
exports.wirePrototypeMethodAsync = wirePrototypeMethodAsync;
function argumentNames(func) {
    var names = func.toString().match(/^[\s\(]*function[^(]*\(([^)]*)\)/)[1]
        .replace(/\/\/.*?[\r\n]|\/\*(?:.|[\r\n])*?\*\//g, '')
        .replace(/\s+/g, '').split(',');
    return names.length === 1 && !names[0] ? [] : names;
}
